=== BUNDLE: Services (20251113_094855) ===
----- FILE: C:\Users\premo\source\repos\trs3.0nuevo\TRS2.0\Services\EmailSender.cs -----
using Microsoft.Extensions.Options;
using System.Net;
using System.Net.Mail;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.IO;

namespace TRS2._0.Services
{
    // ✅ Nuevo contrato con adjuntos
    public interface IEmailSenderWithAttachments : IEmailSender
    {
        Task SendEmailAsync(string to, string subject, string htmlBody,
                            IEnumerable<EmailAttachment>? attachments,
                            string? copyTo = null,
                            string? replyTo = null,
                            string? fromDisplayName = null);
    }

    // ✅ DTO adjunto reutilizable
    public record EmailAttachment(string FileName, byte[] Content, string ContentType);

    public class EmailSender : IEmailSenderWithAttachments
    {
        private readonly SmtpSettings _smtpSettings;

        public EmailSender(IOptions<SmtpSettings> smtpSettings)
        {
            _smtpSettings = smtpSettings.Value;
        }

        
        // Método "simple" redirige al completo con parámetros opcionales
        public async Task SendEmailAsync(string email, string subject, string message,
                                         string? replyTo = null, string? fromDisplayName = null)
        {
            await SendEmailAsync(
                to: email,
                subject: subject,
                htmlBody: message,
                attachments: null,
                copyTo: null,
                replyTo: replyTo,
                fromDisplayName: fromDisplayName
            );
        }

        // ✅ Nuevo: envío con adjuntos
        // Método completo (con adjuntos + Reply-To + DisplayName)
        public async Task SendEmailAsync(
            string to,
            string subject,
            string htmlBody,
            IEnumerable<EmailAttachment>? attachments,
            string? copyTo = null,
            string? replyTo = null,
            string? fromDisplayName = null)
        {
            using var client = new SmtpClient(_smtpSettings.Host, _smtpSettings.Port)
            {
                Credentials = new NetworkCredential(_smtpSettings.Username, _smtpSettings.Password),
                EnableSsl = true
            };

            var from = new MailAddress($"{_smtpSettings.Username}@bsc.es",
                string.IsNullOrWhiteSpace(fromDisplayName) ? null : fromDisplayName);

            using var mail = new MailMessage
            {
                From = from,
                Subject = subject,
                Body = htmlBody,
                IsBodyHtml = true
            };

            mail.To.Add(to);

            if (!string.IsNullOrWhiteSpace(copyTo))
                mail.Bcc.Add(copyTo); // usa CC si quieres que sea visible

            if (!string.IsNullOrWhiteSpace(replyTo))
                mail.ReplyToList.Add(new MailAddress(replyTo));

            // Cabeceras útiles (opcional)
            mail.Headers.Add("X-Auto-Response-Suppress", "All");
            mail.Headers.Add("Auto-Submitted", "auto-generated");

            if (attachments != null)
            {
                foreach (var a in attachments)
                {
                    var stream = new MemoryStream(a.Content);
                    var att = new Attachment(stream, a.FileName, a.ContentType);
                    mail.Attachments.Add(att);
                }
            }

            await client.SendMailAsync(mail);
        }
       
    }

    public class SmtpSettings
    {
        public string Host { get; set; }
        public int Port { get; set; }
        public string Username { get; set; }
        public string Password { get; set; }
    }

    public interface IEmailSender
    {
        Task SendEmailAsync(string email, string subject, string message,
                            string? replyTo = null, string? fromDisplayName = null);
    }
}




----- FILE: C:\Users\premo\source\repos\trs3.0nuevo\TRS2.0\Services\LoadDataService.cs -----
using Microsoft.EntityFrameworkCore;
using TRS2._0.Data;
using TRS2._0.Models.DataModels;
using Quartz;
using System.Threading.Tasks;
using System.Globalization;
using Serilog;
using Newtonsoft.Json;
using System.Net.Http.Headers;
using static TRS2._0.Services.WorkCalendarService;
using System.Text;
using System.Timers;
using Newtonsoft.Json.Linq;
using System.Text.Json;
using Microsoft.AspNetCore.Mvc;
using OfficeOpenXml;
using System.Composition;
using ILogger = Serilog.ILogger;



namespace TRS2._0.Services
{
    public class LoadDataService : IJob
    {        
        private readonly TRSDBContext _context;
        private readonly WorkCalendarService _workCalendarService;
        private readonly ILogger<LoadDataService> _logger;
        private readonly HttpClient _httpClient;
        private string _bearerToken;
        private DateTime _nextTokenRenewalDate;
        private System.Timers.Timer _tokenRenewalTimer;
        private readonly string _tokenFilePath;
        private readonly ILogger _fileLogger = new LoggerConfiguration()
                                                .MinimumLevel.Debug()
                                                .WriteTo.File(Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CargaDiaria.txt"),
                                                              rollingInterval: RollingInterval.Day)
                                                .CreateLogger();


        public LoadDataService(TRSDBContext context, WorkCalendarService workCalendarService, ILogger<LoadDataService> logger)
        {
            _context = context;
            _workCalendarService = workCalendarService;
            _logger = logger;
            _httpClient = new HttpClient();

            // Configurar la ruta del archivo para guardar el token
            var tokenDirectory = Path.Combine(Directory.GetCurrentDirectory(), "Token");
            if (!Directory.Exists(tokenDirectory))
            {
                Directory.CreateDirectory(tokenDirectory);
            }
            _tokenFilePath = Path.Combine(tokenDirectory, "bearerToken.json");

            // Inicializar la gestión del token
            InitializeTokenRenewalAsync().GetAwaiter().GetResult();
        }


        // Método para actualizar los valores mensuales de PM
        public async Task UpdateMonthlyPMs()
        {
            // Ruta del archivo de logs para registrar el proceso
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "MonthlyPM.txt");
            
            // Configuración del logger para este proceso
            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            try
            {
                // Obtener todas las personas registradas en el sistema
                var persons = await _context.Personnel.ToListAsync();

                foreach (var person in persons)
                {
                    // Notificar en el log que estamos procesando a una persona específica
                    logger.Information($"Processing PMs for PersonId: {person.Id}, Name: {person.Name} {person.Surname}");

                    // Obtener los meses relevantes para esta persona
                    var totalMonths = await RelevantMonths(person.Id);

                    // Iterar sobre cada mes relevante
                    foreach (var month in totalMonths)
                    {
                        // Calcular el valor de PM para esta persona en el mes y año especificados
                        var pmValue = await _workCalendarService.CalculateMonthlyPM(person.Id, month.Year, month.Month);

                        // Verificar si ya existe un registro de PM para esta persona y mes
                        var existingRecord = await _context.PersMonthEfforts
                            .FirstOrDefaultAsync(pme => pme.PersonId == person.Id && pme.Month == new DateTime(month.Year, month.Month, 1));

                        if (existingRecord != null)
                        {
                            // Actualizar el registro existente si ya hay uno
                            existingRecord.Value = pmValue;
                            logger.Information($"Updated PM value for PersonId: {person.Id} in {month.Year}-{month.Month}: {pmValue}");
                        }
                        else
                        {
                            // Crear un nuevo registro si no existe
                            var newRecord = new PersMonthEffort
                            {
                                PersonId = person.Id,
                                Month = new DateTime(month.Year, month.Month, 1),
                                Value = pmValue
                            };
                            _context.PersMonthEfforts.Add(newRecord);

                            // Registrar la creación del nuevo valor
                            logger.Information($"Created new PM value for PersonId: {person.Id} in {month.Year}-{month.Month}: {pmValue}");
                        }
                    }

                    // Guardar los cambios en la base de datos después de procesar todos los meses de la persona
                    await _context.SaveChangesAsync();
                    logger.Information($"Finished processing PMs for PersonId: {person.Id}");
                }
            }
            catch (Exception ex)
            {
                // Registrar cualquier error ocurrido durante el proceso
                logger.Error($"Error in UpdateMonthlyPMs: {ex.Message}");
            }
            finally
            {
                // Liberar el recurso del logger
                logger.Dispose();
            }
        }

        // Método para calcular los meses relevantes de una persona
        public async Task<List<DateTime>> RelevantMonths(int personId)
        {
            // Obtener las fechas de inicio y fin de los contratos de la persona
            var contracts = await _context.Dedications
                .Where(d => d.PersId == personId)
                .Select(d => new { d.Start, d.End })
                .OrderBy(d => d.Start)
                .ToListAsync();

            // Si no hay contratos, devolver una lista vacía
            if (!contracts.Any())
            {
                return new List<DateTime>();
            }

            // Determinar el año actual
            var currentYear = DateTime.UtcNow.Year;

            // Establecer los límites de cálculo: 2 años hacia atrás y 2 años hacia adelante desde el año actual, el primer valor  es el que marca los años atras y adelante 
            var lowerLimit = new DateTime(currentYear - 1, 1, 1); // Inicio del rango permitido
            var upperLimit = new DateTime(currentYear + 6, 1, 31); // Fin del rango permitido

            // Obtener el rango de fechas del primer y último contrato
            var start = contracts.First().Start < lowerLimit ? lowerLimit : contracts.First().Start; // Limitar al rango inferior
            var end = contracts.Last().End > upperLimit ? upperLimit : contracts.Last().End; // Limitar al rango superior

            // Generar una lista de todos los meses entre el inicio y el fin del rango permitido
            List<DateTime> months = new List<DateTime>();
            for (var date = new DateTime(start.Year, start.Month, 1); date <= end; date = date.AddMonths(1))
            {
                months.Add(date);
            }

            return months;
        }


        

        public async Task LoadLiquidationsFromFileAsync(string filePath)
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CargaLiquidacionesLog.txt");

            var personalLogger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            var lines = await File.ReadAllLinesAsync(filePath);
            int totalLiquidations = 0;
            int correctLiquidations = 0;
            int incorrectLiquidations = 0;

            foreach (var line in lines)
            {
                try
                {
                    var fields = line.Split('\t');
                    var format = "yyyy-MM-dd HH:mm:ss.fff"; // Define el formato de fecha esperado

                    DateTime start, end;

                    // Intenta parsear la fecha de inicio
                    if (!DateTime.TryParseExact(fields[6], format, CultureInfo.InvariantCulture, DateTimeStyles.None, out start))
                    {
                        personalLogger.Warning($"Failed to parse Start Date for Liquidation from field: {fields[6]}");
                        incorrectLiquidations++;
                        continue;
                    }

                    // Intenta parsear la fecha de fin
                    if (!DateTime.TryParseExact(fields[7], format, CultureInfo.InvariantCulture, DateTimeStyles.None, out end))
                    {
                        personalLogger.Warning($"Failed to parse End Date for Liquidation from field: {fields[7]}");
                        incorrectLiquidations++;
                        continue;
                    }

                    var liquidation = new Liquidation
                    {
                        Id = fields[0],
                        PersId = int.Parse(fields[1]),
                        Project1 = fields[2],
                        Dedication1 = decimal.Parse(fields[3], CultureInfo.InvariantCulture),
                        Project2 = string.IsNullOrWhiteSpace(fields[4]) ? null : fields[4],
                        Dedication2 = string.IsNullOrWhiteSpace(fields[5]) ? null : decimal.Parse(fields[5], CultureInfo.InvariantCulture),
                        Start = start,
                        End = end,
                        Destiny = fields[8],
                        Reason = fields[9],
                        Status = "0" // Estado inicial es un valor "0"
                    };

                    // Verificar si la liquidación ya existe en el sistema
                    var existingLiquidation = await _context.Liquidations.FirstOrDefaultAsync(l => l.Id == liquidation.Id);
                    if (existingLiquidation != null)
                    {
                        // Verificar si los datos son iguales
                        if (existingLiquidation.PersId == liquidation.PersId &&
                            existingLiquidation.Project1 == liquidation.Project1 &&
                            existingLiquidation.Dedication1 == liquidation.Dedication1 &&
                            existingLiquidation.Project2 == liquidation.Project2 &&
                            existingLiquidation.Dedication2 == liquidation.Dedication2 &&
                            existingLiquidation.Start == liquidation.Start &&
                            existingLiquidation.End == liquidation.End)
                        {
                            personalLogger.Information($"Liquidation {liquidation.Id} already exists and has the same data. Skipping.");
                            continue; // Pasar a la siguiente línea
                        }
                        else
                        {
                            // Actualizar los datos de la liquidación existente
                            existingLiquidation.PersId = liquidation.PersId;
                            existingLiquidation.Project1 = liquidation.Project1;
                            existingLiquidation.Dedication1 = liquidation.Dedication1;
                            existingLiquidation.Project2 = liquidation.Project2;
                            existingLiquidation.Dedication2 = liquidation.Dedication2;
                            existingLiquidation.Start = liquidation.Start;
                            existingLiquidation.End = liquidation.End;
                            existingLiquidation.Status = "1"; // Cambiar el estado a "1" si los datos han cambiado

                            personalLogger.Information($"Liquidation {liquidation.Id} already exists but has different data. Updating data and status to 1.");
                        }
                    }
                    else
                    {
                        // Dentro de tu bucle de carga
                        int persId = int.Parse(fields[1]);
                        var personnelExists = await _context.Personnel.AnyAsync(p => p.Id == persId);
                        if (!personnelExists)
                        {
                            personalLogger.Warning($"Personnel with Id {persId} not found. Skipping liquidation.");
                            incorrectLiquidations++;
                            continue; // Salta al siguiente registro
                        }
                        // Procede a insertar la liquidación si el personal existe

                        await _context.Liquidations.AddAsync(liquidation);
                        personalLogger.Information($"Liquidation {liquidation.Id} loaded from file.");
                    }

                    correctLiquidations++;
                }
                catch (Exception ex)
                {
                    personalLogger.Error($"An error occurred while processing liquidation: {ex.Message}");
                    incorrectLiquidations++;
                }

                totalLiquidations++;
            }

            await _context.SaveChangesAsync(); // Guardar todos los cambios en la base de datos

            personalLogger.Information($"Total liquidations processed: {totalLiquidations}");
            personalLogger.Information($"Correct liquidations: {correctLiquidations}");
            personalLogger.Information($"Incorrect liquidations: {incorrectLiquidations}");
        }


        public async Task ProcessLiquidationsAsync()
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "ProcessLiquidationsLog.txt");

            var personalLogger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            try
            {
                int successfulCount = 0;
                int errorCount = 0;

                // Excluye las liquidaciones en estado 3, 4 y ahora también 5.
                var liquidations = await _context.Liquidations
                    .Where(l => l.Status != "3" && l.Status != "4" && l.Status != "5" && l.Status != "6")
                    .ToListAsync();

                foreach (var liquidation in liquidations)
                {
                    try
                    {
                        // Eliminar los datos asociados a la liquidacion en la tabla Liqdayxproject
                        var liqDayProjects = await _context.liqdayxproject
                            .Where(ldp => ldp.LiqId == liquidation.Id)
                            .ToListAsync();

                        _context.liqdayxproject.RemoveRange(liqDayProjects);
                        bool isOverride = liquidation.Status == "7";

                        if (!isOverride && (liquidation.Destiny == "BARCELONA" || (liquidation.End - liquidation.Start).TotalDays >= 30))
                        {
                            liquidation.Status = "4";
                            personalLogger.Information($"Liquidation {liquidation.Id} processed successfully. Status: 4");
                            successfulCount++;
                            continue;
                        }

                        // Verifica si Project1 y Project2 son el mismo, lo cual es un error sin la suma de sus dedicaciones es mayor a 100
                        if (!string.IsNullOrEmpty(liquidation.Project1) && liquidation.Project1 == liquidation.Project2)
                        {
                            decimal dedicationSum = liquidation.Dedication1 + (liquidation.Dedication2 ?? 0);
                            if (dedicationSum > 100)
                            {
                                personalLogger.Error($"Error en liquidación {liquidation.Id}: Project1 y Project2 son iguales y la suma de sus dedicaciones es mayor a 100. Marcando como estado 5 y pasando a la siguiente.");
                                liquidation.Status = "5";
                                personalLogger.Information($"Liquidation {liquidation.Id} processed successfully. Status: 5");
                                errorCount++;
                                continue;
                            }
                            else
                            {
                                personalLogger.Warning($"Advertencia en liquidación {liquidation.Id}: Project1 y Project2 son iguales pero la suma de sus dedicaciones es menor o igual a 100. Procesando Liquidacion");

                                // Actualizar Project1 con la suma de las dedicaciones
                                liquidation.Dedication1 = dedicationSum;
                                liquidation.Project2 = null;
                            }
                        }

                        var startDate = liquidation.Start;
                        var endDate = liquidation.End;
                        var daysInTrip = (endDate - startDate).TotalDays + 1;

                        for (int i = 0; i < daysInTrip; i++)
                        {
                            DateTime currentDay = startDate.AddDays(i);
                            bool isWeekend = await _workCalendarService.IsWeekend(currentDay);
                            bool isHoliday = await _workCalendarService.IsHoliday(currentDay);

                            foreach (var projectCode in new[] { liquidation.Project1, liquidation.Project2 }.Where(p => !string.IsNullOrEmpty(p)))
                            {
                                if (projectCode?.Length == 8)
                                {
                                    var formattedProjectCode = projectCode.Substring(0, projectCode.Length - 2) + "00";
                                    var project = await _context.Projects.FirstOrDefaultAsync(p => p.SapCode == formattedProjectCode);
                                    if (project == null) continue;

                                    decimal dedication = projectCode == liquidation.Project1 ? liquidation.Dedication1 : liquidation.Dedication2 ?? 0;
                                    decimal adjustedPmValue = 0;

                                    if (!isWeekend && !isHoliday)
                                    {
                                        decimal dailyPm = await _workCalendarService.CalculateDailyPM(liquidation.PersId, currentDay);
                                        adjustedPmValue = dailyPm * (dedication / 100);
                                    }

                                    var liqDayProject = new Liqdayxproject
                                    {
                                        LiqId = liquidation.Id,
                                        PersId = liquidation.PersId,
                                        ProjId = project.ProjId,
                                        Day = currentDay,
                                        Dedication = dedication,
                                        PMs = adjustedPmValue,
                                        Status = "0"
                                    };

                                    _context.liqdayxproject.Add(liqDayProject);
                                }
                            }

                        }

                        liquidation.Status = "3";
                        personalLogger.Information($"Liquidation {liquidation.Id} processed successfully. Status: 3");
                        successfulCount++;
                    }
                    catch (Exception ex)
                    {
                        personalLogger.Error($"Error processing liquidation {liquidation.Id}: {ex.Message}");
                        errorCount++;
                    }
                }

                await _context.SaveChangesAsync();

                personalLogger.Information($"Process completed. {successfulCount} liquidations processed successfully. {errorCount} liquidations encountered errors.");
            }
            catch (Exception ex)
            {
                personalLogger.Error($"Error processing liquidations: {ex.Message}");
            }
        }

        // Función para el tratamiento de las lineas de Liqdayxproject
        public async Task ProcessAdvancedLiquidationsAsync()
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "ProcessAdvancedLiquidationsLog.txt");

            var personalLogger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            // Registrar el inicio del procesamiento de liquidaciones avanzadas
            personalLogger.Information("Iniciando Procesamiento de Liquidaciones Avanzadas");

            try
            {
                // Agrupar las liquidaciones por código, mes, año y persona
                var groupedLiquidations = await _context.liqdayxproject
                    .GroupBy(l => new {l.ProjId, l.Day.Month, l.Day.Year, l.PersId })
                    .ToListAsync();

                int successfulLines = 0;
                int failedLines = 0;

                foreach (var group in groupedLiquidations)
                {
                    // Registrar la información del grupo
                    personalLogger.Information($"Procesando liquidaciones para: ProjId={group.Key.ProjId}, Mes={group.Key.Month}, Año={group.Key.Year}, PersId={group.Key.PersId}");

                    // Verificar si algún valor de estado en el grupo es 0
                    bool shouldProcess = group.Any(l => l.Status == "0");

                    if (shouldProcess)
                    {
                        // Sumar todos los PM en el grupo
                        decimal totalPms = group.Sum(l => l.PMs);

                        // Verificar si la persona está asociada al proyecto
                        bool isAssociated = await _context.Projectxpeople
                            .AnyAsync(p => p.ProjId == group.Key.ProjId && p.Person == group.Key.PersId);

                        if (!isAssociated)
                        {
                            // Asociar la persona al proyecto
                            var newProjectxperson = new Projectxperson
                            {
                                ProjId = group.Key.ProjId,
                                Person = group.Key.PersId
                            };
                            _context.Projectxpeople.Add(newProjectxperson);
                            await _context.SaveChangesAsync();

                            // Registrar la asociación de la persona con el proyecto
                            personalLogger.Information($"Asociada la persona {group.Key.PersId} con el proyecto {group.Key.ProjId}");
                        }

                        // Obtener el esfuerzo acumulado para la persona en el proyecto
                        decimal accumulatedEffort = await _workCalendarService.GetEffortForPersonInProject(group.Key.PersId, group.Key.ProjId, group.Key.Year, group.Key.Month);

                        if (accumulatedEffort >= totalPms)
                        {
                            // Establecer todas las líneas del grupo con estado 1
                            foreach (var liquidation in group)
                            {
                                liquidation.Status = "1";
                            }

                            // Registrar el procesamiento exitoso de las liquidaciones
                            personalLogger.Information($"Procesadas {group.Count()} líneas exitosamente");
                            successfulLines += group.Count();
                        }
                        else
                        {
                            // Verificar si existe el WP de viajes para el proyecto
                            var wpTravels = await _context.Wps.FirstOrDefaultAsync(w => w.ProjId == group.Key.ProjId && w.Name == "TRAVELS");
                            
                            if (wpTravels == null)
                            {
                                var project = await _context.Projects.FirstOrDefaultAsync(p => p.ProjId == group.Key.ProjId);
                                // Crear el WP de viajes con la duración completa del proyecto
                                wpTravels = new Wp
                                {
                                    ProjId = group.Key.ProjId,
                                    Name = "TRAVELS",
                                    StartDate = (DateTime)project.Start,
                                    EndDate = (DateTime)project.EndReportDate,
                                    Pms = 0
                                };
                                _context.Wps.Add(wpTravels);
                                await _context.SaveChangesAsync();

                                // Asociar la persona al WP de viajes
                                var newWpxperson = new Wpxperson
                                {
                                    Wp = wpTravels.Id,
                                    Person = group.Key.PersId
                                };
                                _context.Wpxpeople.Add(newWpxperson);
                                await _context.SaveChangesAsync();

                                // Registrar la creación del WP de viajes y la asociación con la persona
                                personalLogger.Information($"Creado WP de viajes para el proyecto {group.Key.ProjId} y asociada la persona {group.Key.PersId}");
                            }
                            else
                            {
                                // Verificar si la persona está asociada al WP de viajes
                                bool isAssociatedWithTravels = await _context.Wpxpeople
                                    .AnyAsync(w => w.Wp == wpTravels.Id && w.Person == group.Key.PersId);

                                if (!isAssociatedWithTravels)
                                {
                                    // Asociar la persona al WP de viajes
                                    var newWpxperson = new Wpxperson
                                    {
                                        Wp = wpTravels.Id,
                                        Person = group.Key.PersId
                                    };
                                    _context.Wpxpeople.Add(newWpxperson);
                                    await _context.SaveChangesAsync();

                                    // Registrar la asociación de la persona con el WP de viajes
                                    personalLogger.Information($"Asociada la persona {group.Key.PersId} con el WP de viajes");
                                }
                            }
                            // Obtener el ID de la persona en el WP de viajes
                            var wpxpersonid = await _context.Wpxpeople
                                .Where(w => w.Wp == wpTravels.Id && w.Person == group.Key.PersId)
                                .Select(w => w.Id)
                                .FirstOrDefaultAsync();

                            //Comprobar si ya existe una línea de Perseffort para el mes
                            var existingPerseffort = await _context.Persefforts
                                .FirstOrDefaultAsync(p => p.WpxPerson == wpxpersonid && p.Month == new DateTime(group.Key.Year, group.Key.Month, 1));

                            if (existingPerseffort != null)
                            {
                                // Actualizar el valor existente
                                existingPerseffort.Value += totalPms - accumulatedEffort;
                            }
                            else
                            {
                                

                                // Agregar una nueva línea de Perseffort para el mes
                                var newPerseffort = new Perseffort
                                {
                                    WpxPerson = wpxpersonid,
                                    Month = new DateTime(group.Key.Year, group.Key.Month, 1),
                                    Value = totalPms - accumulatedEffort 
                                };
                                _context.Persefforts.Add(newPerseffort);
                                await _context.SaveChangesAsync();

                                // Establecer todas las líneas del grupo con estado 1
                                foreach (var liquidation in group)
                                {
                                    liquidation.Status = "1";
                                }

                                // Registrar el procesamiento exitoso de las liquidaciones
                                personalLogger.Information($"Procesadas {group.Count()} líneas exitosamente");
                                successfulLines += group.Count();
                            }
                                                        
                        }
                        await _context.SaveChangesAsync();
                    }
                }

                // Registrar la finalización del procesamiento de liquidaciones avanzadas
                personalLogger.Information("Procesamiento de Liquidaciones Avanzadas completado exitosamente");

                // Registrar el número total de líneas exitosas y fallidas
                personalLogger.Information($"Total de líneas exitosas: {successfulLines}");
                personalLogger.Information($"Total de líneas fallidas: {failedLines}");
            }
            catch (Exception ex)
            {
                // Registrar cualquier excepción que ocurra durante el procesamiento de liquidaciones avanzadas
                personalLogger.Error(ex, "Error ocurrido durante el Procesamiento de Liquidaciones Avanzadas");
            }
        }

        public async Task<IActionResult> CancelLiquidation(string liquidationId)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                var logger = new LoggerConfiguration()
                    .MinimumLevel.Debug()
                    .WriteTo.File(Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CancelLiquidationLog.txt"), rollingInterval: RollingInterval.Day)
                    .CreateLogger();

                logger.Information($"Starting cancellation process for Liquidation ID: {liquidationId}");

                // Recuperar la liquidación
                var liquidation = await _context.Liquidations.FindAsync(liquidationId);
                if (liquidation == null)
                {
                    logger.Warning($"Liquidation with ID {liquidationId} not found.");
                    return new JsonResult(new { success = false, message = "Liquidation not found." });
                }

                // Obtener registros de liqdayxproject relacionados
                var liqDayProjects = await _context.liqdayxproject
                    .Where(ld => ld.LiqId == liquidationId)
                    .ToListAsync();

                if (!liqDayProjects.Any())
                {
                    logger.Warning($"No associated liqdayxproject records found for Liquidation ID: {liquidationId}");
                    return new JsonResult(new { success = false, message = "No associated project records found for liquidation." });
                }

                // Agrupar por proyecto, mes y persona
                var groupedByProjectMonthPerson = liqDayProjects
                    .GroupBy(ld => new { ld.ProjId, ld.PersId, Month = ld.Day.Month, Year = ld.Day.Year })
                    .ToList();

                foreach (var group in groupedByProjectMonthPerson)
                {
                    var projectId = group.Key.ProjId;
                    var personId = group.Key.PersId;
                    var month = group.Key.Month;
                    var year = group.Key.Year;

                    // Obtener esfuerzo total para el grupo
                    var totalEffortForMonth = group.Sum(ld => ld.PMs);

                    // Encontrar WP "TRAVELS" asociado a la persona
                    var travelsWpx = await _context.Wpxpeople
                        .Include(wpx => wpx.WpNavigation)
                        .FirstOrDefaultAsync(wpx => wpx.WpNavigation.ProjId == projectId && wpx.Person == personId && wpx.WpNavigation.Name == "TRAVELS");

                    if (travelsWpx == null)
                    {
                        logger.Information($"No 'TRAVELS' WP found for Project ID: {projectId} and Person ID: {personId}. Skipping adjustments.");
                        continue;
                    }

                    // Obtener todos los viajes en el mismo mes, proyecto y persona
                    var allTravelsForMonth = await _context.liqdayxproject
                        .Where(ld => ld.ProjId == projectId && ld.PersId == personId && ld.Day.Month == month && ld.Day.Year == year && ld.LiqId != liquidationId)
                        .ToListAsync();

                    // Obtener esfuerzo en otros paquetes de trabajo (excluyendo "TRAVELS") para la persona
                    var otherEffortsForMonth = await _context.Persefforts
                        .Where(pe => pe.WpxPersonNavigation.Person == personId && pe.WpxPersonNavigation.WpNavigation.ProjId == projectId && pe.WpxPerson != travelsWpx.Id && pe.Month.Month == month && pe.Month.Year == year)
                        .SumAsync(pe => pe.Value);

                    // Ajustar esfuerzos en "TRAVELS" si es necesario
                    var effortEntry = await _context.Persefforts
                        .FirstOrDefaultAsync(pe => pe.WpxPerson == travelsWpx.Id && pe.Month.Month == month && pe.Month.Year == year);

                    if (effortEntry != null)
                    {
                        if (allTravelsForMonth.Count == 0)
                        {
                            // Si solo hay un viaje, eliminar todo el esfuerzo de "TRAVELS"
                            effortEntry.Value = 0;
                            _context.Persefforts.Update(effortEntry);
                        }
                        else
                        {
                            var totalTravelEffort = allTravelsForMonth.Sum(ld => ld.PMs);
                            

                            if (otherEffortsForMonth >= totalTravelEffort)
                            {                                
                                effortEntry.Value = 0;
                                _context.Persefforts.Update(effortEntry);
                                logger.Information($"Enough effort in project. TRAVELS effort adjusted to 0.");
                            }
                            else
                            {
                                var effortToAdjust = totalTravelEffort - otherEffortsForMonth;
                                effortEntry.Value -= effortToAdjust;
                                _context.Persefforts.Update(effortEntry);
                                logger.Information($"TRAVELS adjusted to: {effortEntry}.");
                            }
                        }
                    }
                }

                // Eliminar registros de liqdayxproject
                _context.liqdayxproject.RemoveRange(liqDayProjects);
                logger.Information($"Deleted {liqDayProjects.Count} records from liqdayxproject.");

                // Actualizar estado de la liquidación
                liquidation.Status = "6"; // Cancelada
                _context.Liquidations.Update(liquidation);
                logger.Information($"Liquidation ID {liquidationId} marked as canceled.");

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();

                logger.Information($"Successfully completed cancellation for Liquidation ID: {liquidationId}.");
                return new JsonResult(new { success = true, message = "Liquidation successfully canceled." });
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                return new JsonResult(new { success = false, message = $"Error canceling liquidation: {ex.Message}" });
            }
        }






        public async Task LoadPersonnelFromFileAsync(string filePath)
        {
            try
            {
                var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CargaPersonnelLog.txt");

                var personalLogger = new LoggerConfiguration()
                    .MinimumLevel.Debug()
                    .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                    .CreateLogger();
                var lines = await File.ReadAllLinesAsync(filePath);
                foreach (var line in lines)
                {
                    var fields = line.Split('\t');
                    // Parsea el Id
                    if (!int.TryParse(fields[0], out int personnelId))
                    {
                        personalLogger.Error($"Failed to parse Personnel Id from field: {fields[0]}");
                        continue;
                    }
                    var format = "yyyy-MM-dd HH:mm:ss.fff"; // Define el formato de fecha esperado

                    DateTime startDate, endDate;

                    // Intenta parsear la fecha de inicio
                    if (!DateTime.TryParseExact(fields[9], format, CultureInfo.InvariantCulture, DateTimeStyles.None, out startDate))
                    {
                        personalLogger.Error($"Failed to parse Start Date for Personnel from field: {fields[9]}");
                        continue;
                    }

                    // Intenta parsear la fecha de fin
                    if (!DateTime.TryParseExact(fields[5], format, CultureInfo.InvariantCulture, DateTimeStyles.None, out endDate))
                    {
                        personalLogger.Error($"Failed to parse End Date for Personnel from field: {fields[5]}");
                        continue;
                    }

                    var personnel = await _context.Personnel
                                        .AsNoTracking()
                                        .FirstOrDefaultAsync(p => p.Id == personnelId);
                    personalLogger.Information($"Attempting to add/update Personnel: {personnelId}");

                    int department = 0, resp, personnelGroup = 0, a3code = 0;
                    bool parseResp = int.TryParse(fields[7], out resp);

                    if (!parseResp)
                    {
                        resp = 0; // Asignar resp a null si falla el parseo   
                        personalLogger.Error($"Failed to parse essential field Resp for Personnel {fields[3]} {fields[2]}");
                    }


                    // Intenta parsear los campos opcionales con manejo de errores
                    if (!int.TryParse(fields[4], out department))
                    {
                        department = 0;
                        personalLogger.Warning($"Failed to parse Department for Personnel {fields[3]} {fields[2]}");
                    }

                    if (!int.TryParse(fields[10], out personnelGroup))
                    {
                        personnelGroup = 0;
                        personalLogger.Warning($"Failed to parse PersonnelGroup for Personnel {fields[3]} {fields[2]}, setting default value to 0");
                    }

                    if (!int.TryParse(fields[13], out a3code))
                    {
                        a3code = 0;
                        personalLogger.Warning($"Failed to parse A3Code for Personnel {fields[3]} {fields[2]}, setting default value to 0");
                    }

                    if (personnel == null)
                    {
                        personnel = new Personnel
                        {
                            Id = personnelId,
                            Email = fields[1],
                            Surname = fields[2],
                            Name = fields[3],
                            Department = department,
                            EndDate = endDate,
                            Category = fields[6],
                            Resp = resp,
                            StartDate = startDate,
                            PersonnelGroup = personnelGroup,
                            A3code = a3code,
                            BscId = !string.IsNullOrWhiteSpace(fields[14]) ? fields[14] : null,
                            UserId = null,
                            Password = string.Empty, // Set an empty string instead of null
                            PermissionLevel = null
                        };
                        _context.Personnel.Add(personnel);
                        personalLogger.Information($"Personnel {personnel.Name} {personnel.Surname} added to database.");
                    }
                    else
                    {
                        personnel.Email = fields[1];
                        personnel.Surname = fields[2];
                        personnel.Name = fields[3];
                        personnel.Department = department;
                        personnel.EndDate = endDate;
                        personnel.Category = fields[6];
                        personnel.Resp = resp;
                        personnel.StartDate = startDate;
                        personnel.PersonnelGroup = personnelGroup;
                        personnel.A3code = a3code;
                        if (!string.IsNullOrWhiteSpace(fields[14]))
                        {
                            personnel.BscId = fields[14];
                        }
                        // No se actualizan los campos UserId, Password y PermissionLevel
                        _context.Personnel.Update(personnel);
                        personalLogger.Information($"Personnel {personnel.Name} {personnel.Surname} updated in database.");
                    }
                }
                try
                {
                    await _context.SaveChangesAsync(); // Guardar todos los cambios en la base de datos
                
                    // Código para cargar personal
                    personalLogger.Information("Carga de personal finalizada.");
                }
                catch (DbUpdateException dbEx) // Captura excepciones específicas de Entity Framework
                {
                    personalLogger.Error($"Error al cargar personal: {dbEx.Message}");
                    personalLogger.Error($"Detalles: {dbEx.InnerException?.Message}"); // Muestra el mensaje de la excepción interna
                }
                catch (Exception ex)
                {
                    personalLogger.Error($"Error al cargar personal: {ex.Message}");
                }

                finally
                {
                    personalLogger.Dispose();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al cargar personal: {ex.Message}");
            }
        }

        // Carga las afiliaciones y dedicaciones desde un archivo
        public async Task LoadAffiliationsAndDedicationsFromFileAsync(string filePath)
        {
        var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CargaAfiliacionesYDedicacionesLog.txt");

        var logger = new LoggerConfiguration()
            .MinimumLevel.Debug()
            .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
            .CreateLogger();
        var personIds = await _context.Personnel.Select(p => p.Id).ToListAsync();
            var personIdSet = new HashSet<int>(personIds);

            // Mapa PersonId -> Resp (0 lo tratamos como NULL)
            var personRespMap = await _context.Personnel
                .AsNoTracking()
                .Select(p => new { p.Id, p.Resp })
                .ToDictionaryAsync(x => x.Id, x => x.Resp == 0 ? (int?)null : x.Resp);


            List<string> lineasFallidas = new List<string>();

            logger.Information("Iniciando la carga de afiliaciones y dedicaciones desde el archivo: {FilePath}", filePath);

            try
            {
                // Establecer todos los 'Exist' a 0 al inicio
                logger.Debug("Reseteando el estado Exist de todas las entidades a 0.");
                await _context.Database.ExecuteSqlRawAsync("UPDATE AffxPersons SET Exist = 0");
                await _context.Database.ExecuteSqlRawAsync("UPDATE Dedication SET Exist = 0 WHERE Type <= 1");

                var lines = await File.ReadAllLinesAsync(filePath);
                logger.Information("Archivo leído con {LineCount} líneas.", lines.Length);

                foreach (var line in lines)
                {
                    logger.Debug("Procesando línea: {Line}", line);
                    var fields = line.Split('\t');

                    if (fields.Length < 6) // Ajustado para reflejar la corrección en la cantidad de campos esperados
                    {
                        logger.Error("Línea incompleta: {Line}", line);
                        continue;
                    }

                    if (!int.TryParse(fields[0], out int personId) ||
                        !int.TryParse(fields[1], out int lineId) ||
                        !DateTime.TryParseExact(fields[2], "yyyy-MM-dd HH:mm:ss.fff", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime startDate) ||
                        !DateTime.TryParseExact(fields[3], "yyyy-MM-dd HH:mm:ss.fff", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime endDate) ||
                        !decimal.TryParse(fields[4], NumberStyles.Any, CultureInfo.InvariantCulture, out decimal dedication))
                    {
                        logger.Error("Error al parsear campos esenciales de la línea: {Line}", line);
                        continue;
                    }

                    if (dedication < 0 || dedication > 100)
                    {
                        logger.Error($"Valor inválido en dedication: {dedication}. Se ignorará esta línea: {line}");
                        continue; // Evita procesar la línea con valores erróneos
                    }

                    // Convertir el porcentaje a decimal para `Reduc`
                    dedication = 1m - dedication / 100;

                    string contract = fields[5];
                    // Asegurando que Dist se maneje correctamente como cadena vacía si no existe
                    string dist = fields.Length > 6 ? fields[6] : string.Empty;

                    logger.Debug("Buscando codificación para Contract: {Contract} y Dist: {Dist}", contract, dist);
                    var affCodification = await _context.AffCodifications
                        .Where(ac => ac.Contract == contract && (dist.StartsWith(ac.Dist) || ac.Dist == string.Empty))
                        .OrderByDescending(ac => ac.Dist.Length) // Priorizar la coincidencia más larga
                        .Select(ac => ac.Affiliation)
                        .FirstOrDefaultAsync();

                    // Log para indicar la codificación encontrada o si se asignará un valor por defecto
                    if (affCodification > 0)
                    {
                        logger.Information("Codificación de afiliación encontrada para Contract: {Contract}, Dist: {Dist}. Afiliación asignada: {AffiliationId}.", contract, dist, affCodification);
                    }
                    else
                    {                        
                        logger.Information("No se encontró una codificación de afiliación específica para Contract: {Contract}, Dist: {Dist}. Asignando afiliación por defecto: {AffiliationIdDefault}.", contract, dist);
                        
                    }
                    int affId = affCodification > 0 ? affCodification : 0;

                    // Antes de intentar encontrar o insertar en AffxPersons, registra el intento con el PersonId
                    logger.Debug("Procesando PersonId: {PersonId} con LineId: {LineId}.", personId, lineId);

                    // Procesamiento de AffxPerson
                    var affPerson = await _context.AffxPersons
                    .FirstOrDefaultAsync(ap => ap.PersonId == personId && ap.LineId == lineId);

                    if (!personIds.Contains(personId))
                    {
                        lineasFallidas.Add($"NO SE HAN AÑADIDO LA LINEA \"{line}\" ya que el usuario con id {personId} no se encuentra en la base de datos de personal en la TRS.");
                        continue;
                    }

                    // --- Resolver ResponsibleId histórico SIN EF en el bucle ---
                    // Resp va en la última columna y es entero; antes suele venir un decimal (salario)
                    int? responsibleIdFromFile = null;
                    int respColumnIndex = -1;

                    for (int i = fields.Length - 1; i >= 0; i--)
                    {
                        var token = fields[i]?.Trim();
                        if (string.IsNullOrWhiteSpace(token)) continue;

                        if (int.TryParse(token, NumberStyles.Integer, CultureInfo.InvariantCulture, out var rid))
                        {
                            if (rid > 0) { responsibleIdFromFile = rid; respColumnIndex = i; }
                            break;
                        }
                    }

                    // Validación usando datos en memoria (nada de EF aquí)
                    if (responsibleIdFromFile.HasValue && !personIdSet.Contains(responsibleIdFromFile.Value))
                    {
                        logger.Warning("Resp {RespId} no existe en Personnel (cache in-memory). Línea: {Line}", responsibleIdFromFile, line);
                        responsibleIdFromFile = null;
                    }

                    // Fallback SOLO si el fichero no trae resp válido
                    int? fallbackResponsibleId = null;
                    if (personRespMap.TryGetValue(personId, out var respVal) && respVal.HasValue)
                        fallbackResponsibleId = respVal.Value;

                    int? resolvedResponsibleId = responsibleIdFromFile ?? fallbackResponsibleId;

                    if (responsibleIdFromFile.HasValue)
                    {
                        logger.Information("Resp del fichero (col {ColIndex}): PersonId:{PersonId}, LineId:{LineId}, Resp:{Resp}",
                            respColumnIndex, personId, lineId, responsibleIdFromFile);
                    }
                    else if (resolvedResponsibleId.HasValue)
                    {
                        logger.Information("Resp por fallback (Personnel.Resp): PersonId:{PersonId}, LineId:{LineId}, Resp:{Resp}",
                            personId, lineId, resolvedResponsibleId);
                    }
                    else
                    {
                        logger.Warning("Sin Resp para PersonId:{PersonId}, LineId:{LineId}. Línea: {Line}",
                            personId, lineId, line);
                    }




                    if (affPerson == null)
                    {
                        affPerson = new AffxPerson
                        {
                            PersonId = personId,
                            LineId = lineId,
                            Start = startDate,
                            End = endDate,
                            AffId = affId,
                            Exist = true,
                            ResponsibleId = resolvedResponsibleId          // ← NUEVO
                        };
                        _context.AffxPersons.Add(affPerson);
                        logger.Information("Creando AffxPerson P:{PersonId}, L:{LineId}, [{Start}..{End}], Aff:{AffId}, Resp:{Resp}, Exist:{Exist}",
                            personId, lineId, startDate, endDate, affId, resolvedResponsibleId, affPerson.Exist);

                    }
                    else
                    {
                        affPerson.Start = startDate;
                        affPerson.End = endDate;
                        affPerson.AffId = affId;
                        affPerson.Exist = true;
                        affPerson.ResponsibleId = resolvedResponsibleId;   // ← NUEVO
                        logger.Information("Actualizando AffxPerson P:{PersonId}, L:{LineId}, [{Start}..{End}], Aff:{AffId}, Resp:{Resp}, Exist:{Exist}",
                            personId, lineId, startDate, endDate, affId, resolvedResponsibleId, affPerson.Exist);

                    }

                    // Procesamiento de Dedication
                    var dedicationRecord = await _context.Dedications
                        .FirstOrDefaultAsync(d => d.PersId == personId && d.LineId == lineId);

                    if (dedicationRecord == null)
                    {
                        dedicationRecord = new Dedication
                        {
                            PersId = personId,
                            Reduc = dedication,
                            Start = startDate,
                            End = endDate,
                            LineId = lineId,
                            Type = 0,
                            Exist = true // Marcamos como existente al crear
                        };
                        _context.Dedications.Add(dedicationRecord);
                        logger.Information("Creando nueva entidad Dedication con PersId: {PersId}, Reduc: {Reduc}, Start: {Start}, End: {End}, LineId: {LineId}, Type: {Type}, Exist: {Exist}", personId, dedication, startDate, endDate, lineId, dedicationRecord.Type, dedicationRecord.Exist);
                    }
                    else
                    {
                        dedicationRecord.Reduc = dedication;
                        dedicationRecord.Start = startDate;
                        dedicationRecord.End = endDate;
                        dedicationRecord.Exist = true; // Marcamos como existente al actualizar
                        logger.Information("Actualizando entidad Dedication existente con PersId: {PersId}, Reduc: {Reduc}, Start: {Start}, End: {End}, LineId: {LineId}, Exist: {Exist}", personId, dedication, startDate, endDate, lineId, dedicationRecord.Exist);
                    }
                }

                // Asegurar que las dedicaciones con Type > 1 se mantengan con Exist = 1
                await _context.Dedications.Where(d => d.Type > 1).ForEachAsync(d => d.Exist = true);
                foreach (var msg in lineasFallidas)
                {
                    logger.Warning(msg);
                }

                //Hay que eliminar los registros de tipo 0
                await _context.SaveChangesAsync();
                logger.Information("Carga de afiliaciones y dedicaciones finalizada.");
                
            }
            catch (Exception ex)
            {
                logger.Error(ex, "Ocurrió un error durante la carga de afiliaciones y dedicaciones.");
            }
            finally
            {
                logger.Dispose();
            }
        }

        public async Task LoadPersonnelGroupsFromFileAsync(string filePath)
        {
            // Asegúrate de que la carpeta 'Logs' exista
            var logFolderPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs"); 
            Directory.CreateDirectory(logFolderPath); // Esto creará la carpeta si no existe

            var logFilePath = Path.Combine(logFolderPath, "CargaGruposPersonalLog.txt");

            // Verificar si el archivo de log existe y eliminarlo antes de iniciar el nuevo proceso de logueo
            if (File.Exists(logFilePath))
            {
                try
                {
                    File.Delete(logFilePath);
                }
                catch (IOException ex)
                {
                    // Manejar la excepción si no se puede eliminar el archivo de log, p.ej., porque está siendo usado por otro proceso
                    Console.WriteLine($"No se pudo eliminar el archivo de log existente: {ex.Message}");
                    // Considera cómo manejar este caso: detener la ejecución, continuar sin borrar el log, etc.
                    return; // O manejar de otra manera
                }
            }

            // Configuración de Serilog para escribir en el archivo
            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logFilePath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            try
            {
                
                var lines = await File.ReadAllLinesAsync(filePath);

                foreach (var line in lines)
                {
                    var fields = line.Split('\t');

                    if (fields.Length < 2)
                    {
                        logger.Warning("Línea ignorada debido a falta de campos: {Line}", line);
                        continue;
                    }

                    if (!int.TryParse(fields[0], out var id))
                    {
                        logger.Warning("Línea ignorada debido a ID inválido: {Line}", line);
                        continue;
                    }

                    var groupName = fields[1];
                    var existingGroup = await _context.Personnelgroups.FirstOrDefaultAsync(pg => pg.Id == id);

                    logger.Information("Base de datos activa: {Database}", _context.Database.GetDbConnection().Database);

                    if (existingGroup == null)
                    {
                        var newGroup = new Personnelgroup { Id = id, GroupName = groupName };
                        _context.Personnelgroups.Add(newGroup);
                        logger.Information("Insertando nuevo PersonnelGroup con Id: {Id} y GroupName: {GroupName}", id, groupName);
                    }
                    else
                    {
                        existingGroup.GroupName = groupName;
                        logger.Information("PersonnelGroup existente con Id: {Id}. Actualizando GroupName: {GroupName}", id, groupName);
                    }
                }

                await _context.SaveChangesAsync();
                logger.Information("Proceso de carga de PersonnelGroup completado.");
            }
            catch (Exception ex)
            {
                logger.Error(ex, "Ocurrió un error durante la carga de PersonnelGroup.");
            }
            finally
            {
                logger.Dispose(); // Asegúrate de desechar el logger para liberar recursos y cerrar el archivo de log correctamente
            }
        }

        public async Task LoadLeadersFromFileAsync(string filePath)
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CargaLeadersLog.txt");

            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            logger.Information("Iniciando la carga de líderes desde el archivo: {FilePath}", filePath);

            try
            {
                var lines = await File.ReadAllLinesAsync(filePath);
                logger.Information("Archivo leído con {LineCount} líneas.", lines.Length);

                foreach (var line in lines)
                {
                    logger.Debug("Procesando línea: {Line}", line);
                    var fields = line.Split('\t');

                    if (fields.Length < 4)
                    {
                        logger.Error("Línea incompleta: {Line}", line);
                        continue;
                    }

                    if (!int.TryParse(fields[0], out int id) ||
                        !int.TryParse(fields[2], out int grupoDepartamento) ||
                        !int.TryParse(fields[3], out int leaderId))
                    {
                        logger.Error("Error al parsear campos esenciales de la línea: {Line}", line);
                        continue;
                    }

                    var tipo = fields[1];
                    if (tipo != "G" && tipo != "D")
                    {
                        logger.Error("Tipo inválido (debe ser 'G' o 'D'): {Tipo}", tipo);
                        continue;
                    }

                    // Verificar si el líder ya existe para evitar duplicados
                    var existingLeader = await _context.Leaders
                        .FirstOrDefaultAsync(l => l.Id == id);

                    if (existingLeader == null)
                    {
                        var newLeader = new Leader
                        {
                            //Id = id,//
                            Tipo = tipo,
                            GrupoDepartamento = grupoDepartamento,
                            LeaderId = leaderId
                        };
                        _context.Leaders.Add(newLeader);
                        logger.Information("Insertando nuevo líder con Id: {Id}, Tipo: {Tipo}, GrupoDepartamento: {GrupoDepartamento}, LeaderId: {LeaderId}", id, tipo, grupoDepartamento, leaderId);
                    }
                    else
                    {
                        existingLeader.Tipo = tipo;
                        existingLeader.GrupoDepartamento = grupoDepartamento;
                        existingLeader.LeaderId = leaderId;
                        logger.Information("El líder con Id: {Id} ya existe, actualizando campos.", id);
                    }
                }

                await _context.SaveChangesAsync();
                logger.Information("Carga de líderes finalizada.");
            }
            catch (Exception ex)
            {
                logger.Error(ex, "Ocurrió un error durante la carga de líderes.");
            }
            finally
            {
                logger.Dispose();
            }
        }

        public async Task LoadProjectsFromFileAsync(string filePath)
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CargaProjectsLog.txt");

            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            var failedLines = new List<string>();

            logger.Information("Iniciando la carga de proyectos desde el archivo: {FilePath}", filePath);

            try
            {
                var lines = await File.ReadAllLinesAsync(filePath);
                logger.Information("Archivo leído con {LineCount} líneas.", lines.Length);

                foreach (var line in lines)
                {
                    try
                    {

                        logger.Debug("Procesando línea: {Line}", line);
                    var fields = line.Split('\t');

                    if (fields.Length < 17)
                    {
                            throw new FormatException("Línea incompleta.");
                    }

                    var sapCode = fields[0];
                    var acronim = fields[1];
                    var title = fields[2];
                    var type = fields[3];
                    var sType = fields[4];
                    var contract = fields[5];
                    var start = DateTime.TryParse(fields[6], out DateTime startDate) ? startDate : (DateTime?)null;
                    var end = DateTime.TryParse(fields[7], out DateTime endDate) ? endDate : (DateTime?)null;
                    var pm = int.TryParse(fields[8], out int pmId) ? pmId : (int?)null;
                    var pi = int.TryParse(fields[9], out int piId) ? piId : (int?)null;
                    var st1 = fields[10];
                    var st2 = fields[11];
                    var tpsUpc = fields[12] == "Y" ? (short?)1 : (short?)0;
                    var tpsIcrea = fields[13] == "Y" ? (short?)1 : (short?)0;
                    var tpsCsic = fields[14] == "Y" ? (short?)1 : (short?)0;
                    var visible = fields[15] == "Y" ? (short)1 : (short)0;
                    var fm = int.TryParse(fields[16], out int fmId) ? fmId : (int?)null;

                        // Calcular EndReportDate
                        DateTime endReportDate = endDate != default(DateTime) ? endDate : DateTime.Now;
                    if (fields[15] == "Y" && (type == "EU-H2020" || type == "EU-OTROS" || type == "EU-HE"))
                    {
                        endReportDate = endReportDate.AddMonths(3);
                    }

                    // Suponiendo que 'fields' contiene los datos de una línea del archivo como antes

                    var project = await _context.Projects.FirstOrDefaultAsync(p => p.SapCode == sapCode);

                    if (project == null)
                    {
                        // Crear un nuevo proyecto si no existe
                        project = new Project
                        {
                            // No establecemos ProjId si es generado automáticamente por la base de datos
                            SapCode = sapCode,
                            Acronim = acronim,
                            Title = title,
                            Contract = contract,
                            Start = start,
                            End = end,
                            TpsUpc = tpsUpc,
                            TpsIcrea = tpsIcrea,
                            TpsCsic = tpsCsic,
                            Pi = pi,
                            Pm = pm,
                            Type = type,
                            SType = sType,
                            St1 = st1,
                            St2 = st2,
                            EndReportDate = endReportDate,
                            Visible = visible,
                            Fm = fm
                        };
                        _context.Projects.Add(project);
                        logger.Information("Insertando nuevo proyecto con SapCode: {SapCode}", sapCode);
                    }
                    else
                    {
                        // Actualizar los campos del proyecto existente, excepto ProjId y SapCode
                        project.Acronim = acronim;
                        project.Title = title;
                        project.Contract = contract;
                        project.Start = start;
                        project.End = end;
                        project.TpsUpc = tpsUpc;
                        project.TpsIcrea = tpsIcrea;
                        project.TpsCsic = tpsCsic;
                        project.Pi = pi;
                        project.Pm = pm;
                        project.Type = type;
                        project.SType = sType;
                        project.St1 = st1;
                        project.St2 = st2;
                        project.EndReportDate = endReportDate;
                        project.Visible = visible;
                        project.Fm = fm;
                        logger.Information("Actualizando proyecto existente con SapCode: {SapCode}", sapCode);
                    }

                    await _context.SaveChangesAsync();


                    logger.Information("Procesado proyecto {SapCode}", sapCode);

                    }
                    catch (Exception ex)
                    {
                        failedLines.Add($"Error procesando la línea '{line}': {ex.Message}");
                        logger.Error(ex, "Error al procesar la línea: {Line}", line);
                    }
                }

                if (failedLines.Any())
                {
                    logger.Error("Resumen de líneas con errores:");
                    foreach (var failedLine in failedLines)
                    {
                        logger.Error(failedLine);
                    }
                }
                else
                {
                    logger.Information("Todos los proyectos fueron procesados exitosamente.");
                }
            }
            catch (Exception ex)
            {
                logger.Error(ex, "Ocurrió un error durante la carga de proyectos.");
            }
            finally
            {
                logger.Dispose();
            }
        }

        public async Task FetchAndSaveAgreementEventsAsync()
        {
            try
            {
                var httpClient = new HttpClient();
                httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _bearerToken);

                var response = await httpClient.GetAsync("https://app.woffu.com/api/v1/users/2160572/agreements/events");
                response.EnsureSuccessStatusCode();

                var content = await response.Content.ReadAsStringAsync();
                var eventDtos = JsonConvert.DeserializeObject<List<AgreementEventDto>>(content);

                if (eventDtos != null)
                {
                    var agreementEvents = eventDtos.Select(dto => new AgreementEvent
                    {
                        AgreementEventId = dto.AgreementEventId,
                        Name = dto.Name
                    }).ToList();

                    using (var transaction = await _context.Database.BeginTransactionAsync())
                    {
                        await _context.Database.ExecuteSqlRawAsync("SET IDENTITY_INSERT AgreementEvents ON");
                        _context.AgreementEvents.AddRange(agreementEvents);
                        await _context.SaveChangesAsync();
                        await _context.Database.ExecuteSqlRawAsync("SET IDENTITY_INSERT AgreementEvents OFF");
                        await transaction.CommitAsync();
                    }

                    Console.WriteLine($"Se agregaron {agreementEvents.Count} eventos de acuerdo.");
                    Console.WriteLine("Los cambios se guardaron en la base de datos.");
                }
                else
                {
                    Console.WriteLine("No se encontraron eventos de acuerdo.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ocurrió una excepción: {ex.Message}");
                Console.WriteLine(ex.StackTrace);
            }
        }

        public async Task UpdatePersonnelUserIdsAsync()
        {
            try
            {
                var httpClient = new HttpClient();
                httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _bearerToken);

                var response = await httpClient.GetAsync("https://app.woffu.com/api/v1/users");
                response.EnsureSuccessStatusCode();

                var content = await response.Content.ReadAsStringAsync();
                var users = JsonConvert.DeserializeObject<List<WoffuUser>>(content);

                if (users != null)
                {
                    foreach (var user in users)
                    {
                        var personnel = _context.Personnel.FirstOrDefault(p => p.Email == user.Email);
                        if (personnel != null)
                        {
                            personnel.UserId = user.UserId;
                        }
                    }

                    await _context.SaveChangesAsync();
                    _logger.LogInformation("UserIds actualizados correctamente.");
                }
                else
                {
                    _logger.LogWarning("No se encontraron usuarios en la respuesta de la API.");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Ocurrió una excepción: {ex.Message}");
                _logger.LogError(ex.StackTrace);
            }
        }

        private async Task InitializeTokenRenewalAsync()
        {
            // Intentar cargar el token desde el archivo, renovar si no es válido
            await LoadTokenAsync();

            // Configurar el timer para verificar la renovación periódica
            _tokenRenewalTimer = new System.Timers.Timer(TimeSpan.FromDays(1).TotalMilliseconds); // Cada día
            _tokenRenewalTimer.Elapsed += async (sender, e) => await CheckTokenRenewalAsync();
            _tokenRenewalTimer.AutoReset = true;
            _tokenRenewalTimer.Enabled = true;
        }

        private async Task LoadTokenAsync()
        {
            try
            {
                // Si el archivo no existe, renovar inmediatamente
                if (!File.Exists(_tokenFilePath))
                {
                    _logger.LogWarning("Token file not found. Renewing token...");
                    await RenewTokenAsync();
                    return;
                }

                // Leer el token desde el archivo
                var tokenData = JsonConvert.DeserializeObject<TokenData>(await File.ReadAllTextAsync(_tokenFilePath));

                if (tokenData != null && DateTime.UtcNow < tokenData.Expiration)
                {
                    // Cargar el token y configurar el encabezado de autorización
                    _bearerToken = tokenData.AccessToken;
                    _nextTokenRenewalDate = tokenData.Expiration;
                    _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _bearerToken);

                    _logger.LogInformation($"Token loaded successfully. Expires on: {_nextTokenRenewalDate}");
                }
                else
                {
                    // Si el token ha expirado, renovarlo
                    _logger.LogWarning("Token expired or invalid. Renewing token...");
                    await RenewTokenAsync();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error loading token: {ex.Message}. Renewing token...");
                await RenewTokenAsync(); // Renovar en caso de error
            }
        }

        private async Task CheckTokenRenewalAsync()
        {
            // Renovar el token si la fecha actual está próxima a la fecha de expiración
            if (DateTime.UtcNow >= _nextTokenRenewalDate)
            {
                _logger.LogInformation("Token renewal date reached. Renewing token...");
                await RenewTokenAsync();
            }
        }

        public async Task RenewTokenAsync()
        {
            // Datos necesarios para la solicitud de renovación del token
            var requestData = new Dictionary<string, string>
        {
            { "grant_type", "client_credentials" },
            { "client_id", "23553" },
            { "client_secret", "jMUDt3WEHTctkronPHJJmVe97h8WLMp4wNXc62ll3To%3d" }
        };

            var content = new FormUrlEncodedContent(requestData);
            var response = await _httpClient.PostAsync("https://app.woffu.com/token", content);

            if (response.IsSuccessStatusCode)
            {
                // Leer y deserializar la respuesta del token
                var responseContent = await response.Content.ReadAsStringAsync();
                var tokenResponse = JsonConvert.DeserializeObject<TokenResponse>(responseContent);

                if (tokenResponse != null && !string.IsNullOrEmpty(tokenResponse.access_token))
                {
                    // Actualizar el token y la fecha de expiración
                    _bearerToken = tokenResponse.access_token;
                    _nextTokenRenewalDate = DateTime.UtcNow.AddDays(80);

                    // Actualizar el encabezado de autorización
                    _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _bearerToken);

                    // Guardar el token renovado en el archivo
                    await SaveTokenAsync();

                    _logger.LogInformation($"Token renewed successfully. Next renewal: {_nextTokenRenewalDate}");
                }
                else
                {
                    throw new Exception("La respuesta del token es nula o vacía");
                }
            }
            else
            {
                // Registrar detalles del error
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError($"Error al renovar el token. Código de estado: {response.StatusCode}, Contenido: {errorContent}");
                throw new Exception("Error al renovar el token");
            }
        }

        private async Task SaveTokenAsync()
        {
            try
            {
                // Crear un objeto TokenData con el token y la fecha de expiración
                var tokenData = new TokenData
                {
                    AccessToken = _bearerToken,
                    Expiration = _nextTokenRenewalDate
                };

                // Guardar los datos en un archivo JSON
                await File.WriteAllTextAsync(_tokenFilePath, JsonConvert.SerializeObject(tokenData));

                _logger.LogInformation("Token saved successfully to file.");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error saving token: {ex.Message}");
            }
        }

        class TokenResponse
        {
            public string access_token { get; set; }
        }

        public async Task UpdateLeaveTableAsync()
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "CargaAusencias.txt");
            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            try
            {
                logger.Information("=== Inicio del proceso de actualización de la tabla Leave ===");

                _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _bearerToken);
                var response = await _httpClient.GetAsync("https://app.woffu.com/api/v1/users");
                if (!response.IsSuccessStatusCode)
                {
                    var responseContent = await response.Content.ReadAsStringAsync();
                    logger.Error($"HTTP request failed. Status: {response.StatusCode}, Content: {responseContent}");
                    throw new Exception($"Request failed with status: {response.StatusCode}");
                }

                var content = await response.Content.ReadAsStringAsync();
                var users = JsonConvert.DeserializeObject<JArray>(content);

                foreach (var user in users)
                {
                    if (user["UserKey"] == null || string.IsNullOrEmpty(user["UserKey"].ToString()))
                    {
                        string firstName = user["FirstName"]?.ToString() ?? "Unknown";
                        string lastName = user["LastName"]?.ToString() ?? "Unknown";
                        string email = user["Email"]?.ToString() ?? "Unknown";
                        logger.Warning($"Missing UserKey for user {firstName} {lastName} ({email}). This record needs manual correction.");
                        continue;
                    }

                    int userId = user["UserId"].Value<int>();
                    int userKey = user["UserKey"].Value<int>();
                    logger.Information($"Updating absences for user: {userKey}, WoffuId: {userId}");

                    int personId = _context.Personnel.FirstOrDefault(p => p.Id == userKey)?.Id ?? 0;
                    if (personId == 0)
                    {
                        continue;
                    }

                    // Cargar existentes SIN tracking y clave por Day.Date
                    var existingLeavesList = await _context.Leaves
                        .AsNoTracking()
                        .Where(l => l.PersonId == personId)
                        .ToListAsync();

                    var existingLeaves = existingLeavesList
                        .GroupBy(l => l.Day.Date)
                        .ToDictionary(g => g.Key, g => g.First());

                    await Task.Delay(1500);

                    var allRequests = new List<JToken>();
                    int pageIndex = 0;
                    bool morePages = true;

                    do
                    {
                        var url = $"https://app.woffu.com/api/v1/users/{userId}/requests?pageIndex={pageIndex}&pageSize=100";
                        var requestsResponse = await _httpClient.GetAsync(url);

                        if (!requestsResponse.IsSuccessStatusCode)
                        {
                            var responseContentReq = await requestsResponse.Content.ReadAsStringAsync();
                            logger.Error($"HTTP request failed (userId={userId}). Status: {requestsResponse.StatusCode}, Content: {responseContentReq}");
                            morePages = false;
                            continue;
                        }

                        var requestsContent = await requestsResponse.Content.ReadAsStringAsync();
                        var requestsObject = JsonConvert.DeserializeObject<JObject>(requestsContent);

                        if (requestsObject.ContainsKey("Views"))
                        {
                            var requestsArray = (JArray)requestsObject["Views"];
                            if (requestsArray.Count == 0)
                            {
                                morePages = false;
                            }
                            else
                            {
                                allRequests.AddRange(requestsArray);
                                pageIndex++;
                            }
                        }
                        else
                        {
                            logger.Warning($"'Views' property not found for userId={userId} on pageIndex={pageIndex}.");
                            morePages = false;
                        }

                        await Task.Delay(500);
                    }
                    while (morePages);

                    var requestsArrayCombined = new JArray(allRequests);

                    var groupedDays = requestsArrayCombined
                        .Where(r => r["RequestStatus"]?.ToString() == "Approved")
                        .SelectMany(r =>
                        {
                            var startDate = DateTime.Parse(r["StartDate"].ToString());
                            var endDate = DateTime.Parse(r["EndDate"].ToString());
                            var hours = (decimal?)r["NumberHoursRequested"] ?? 0;
                            var agreementEventId = r["AgreementEventId"]?.Value<int>() ?? 0;

                            return Enumerable.Range(0, (endDate.Date - startDate.Date).Days + 1)
                                .Select(offset => new
                                {
                                    Date = startDate.Date.AddDays(offset), // normalizado a .Date
                                    Hours = hours,
                                    AgreementEventId = agreementEventId
                                });
                        })
                        .GroupBy(x => x.Date)
                        .Select(g => new
                        {
                            Date = g.Key, // ya es .Date
                            TotalHours = g.Sum(x => x.Hours),
                            AgreementEventId = g.First().AgreementEventId
                        });

                    var processedDays = new HashSet<DateTime>();

                    // ====== ALTAS / UPDATES ======
                    foreach (var dayGroup in groupedDays)
                    {
                        var date = dayGroup.Date.Date; // seguridad: .Date
                        var totalHours = dayGroup.TotalHours;
                        var agreementEventId = dayGroup.AgreementEventId;

                        var agreementEvent = await _context.AgreementEvents.FindAsync(agreementEventId);
                        if (agreementEvent == null)
                        {
                            logger.Warning($"AgreementEventId {agreementEventId} not found for PersonId={personId}, Date={date}. Skipping leave.");
                            continue;
                        }

                        // Ignorar bajas con Type = 0 (ej. Working from home, Office, Travels)
                        if (agreementEvent.Type == 0)
                        {
                            logger.Information($"Skipping leave with Type=0 for PersonId={personId}, Date={date}, AgreementEventId={agreementEventId}");
                            continue;
                        }

                        decimal leaveReduction;
                        if (agreementEventId == 1079914)
                        {
                            leaveReduction = 0.5m;
                            logger.Information($"Processing paternity leave (ID=1079914): PersonId={personId}, Date={date}, Reduction={leaveReduction:P}");
                        }
                        else if (totalHours > 0)
                        {
                            leaveReduction = await _workCalendarService.CalculateLeaveReductionAsync(personId, date, totalHours);
                        }
                        else
                        {
                            leaveReduction = 1.00m;
                        }

                        // Buscar primero en el Local del contexto (por si ya se ha adjuntado en este ciclo)
                        var localTracked = _context.Leaves.Local
                            .FirstOrDefault(l => l.PersonId == personId && l.Day == date);

                        Leave target = localTracked;

                        if (target == null)
                        {
                            // Evitar segundo attach: consulta a BD (trackeada) para edición si existe
                            target = await _context.Leaves
                                .FirstOrDefaultAsync(l => l.PersonId == personId && l.Day == date);
                        }

                        if (target != null)
                        {
                            // Si ya existe y no es Type 3, actualiza campos
                            if (target.Type == 3)
                            {
                                logger.Information($"Skipping record with Type 3 for PersonId={personId}, Date={date}.");
                            }
                            else
                            {
                                bool changed = false;

                                var newType = agreementEventId == 1079914 ? 12 : (int)agreementEvent.Type;
                                var newHours = totalHours > 0 ? totalHours : (decimal?)null;

                                if (target.LeaveReduction != leaveReduction) { target.LeaveReduction = leaveReduction; changed = true; }
                                if (target.Hours != newHours) { target.Hours = newHours; changed = true; }
                                if (target.Type != newType) { target.Type = newType; changed = true; }

                                if (changed)
                                {
                                    logger.Information($"Updated leave record for PersonId={personId}, Date={date}, LeaveReduction={leaveReduction}");
                                }
                            }
                        }
                        else
                        {
                            // Asegúrate de que no haya otra instancia en Local con misma PK
                            var alreadyLocal = _context.Leaves.Local
                                .Any(l => l.PersonId == personId && l.Day == date);
                            if (!alreadyLocal)
                            {
                                var newLeave = new Leave
                                {
                                    PersonId = personId,
                                    Day = date,
                                    Type = agreementEventId == 1079914 ? 12 : (int)agreementEvent.Type,
                                    Legacy = false,
                                    LeaveReduction = leaveReduction,
                                    Hours = totalHours > 0 ? totalHours : null
                                };
                                _context.Leaves.Add(newLeave);
                                logger.Information($"Created new leave record for PersonId={personId}, Date={date}, LeaveReduction={leaveReduction}");
                            }
                            else
                            {
                                // Si por cualquier razón existe en Local, actualiza esa instancia
                                var local = _context.Leaves.Local.First(l => l.PersonId == personId && l.Day == date);
                                local.Type = agreementEventId == 1079914 ? 12 : (int)agreementEvent.Type;
                                local.Legacy = false;
                                local.LeaveReduction = leaveReduction;
                                local.Hours = totalHours > 0 ? totalHours : null;
                                logger.Information($"Updated (local) leave record for PersonId={personId}, Date={date}, LeaveReduction={leaveReduction}");
                            }
                        }

                        processedDays.Add(date);
                    }

                    // Guardar y limpiar tracker tras altas/updates del usuario
                    await _context.SaveChangesAsync();
                    _context.ChangeTracker.Clear();

                    // ====== BAJAS ======
                    var daysToDelete = existingLeaves
                        .Where(e => !processedDays.Contains(e.Key) && e.Value.Legacy == false && e.Value.Type != 3)
                        .Select(e => e.Key)
                        .ToList();

                    foreach (var day in daysToDelete)
                    {
                        // Borrado por “stub” para no adjuntar duplicados
                        _context.Leaves.Remove(new Leave { PersonId = personId, Day = day });
                        logger.Information($"Deleted leave record for PersonId={personId}, Date={day}");
                    }

                    await _context.SaveChangesAsync();
                    _context.ChangeTracker.Clear();
                }

                logger.Information("=== Fin del proceso de actualización de la tabla Leave ===");
            }
            catch (Exception ex)
            {
                logger.Error($"Error in UpdateLeaveTableAsync: {ex.Message}");
                throw;
            }
            finally
            {
                logger.Dispose();
            }
        }


        // PENDIENTE: ES NECESARIO AJUSTAR LA FECHA MÁXIMA SEGÚN SE DECIDA EN PRINCIPIO NO DEBE SER MAYOR QUE EL DÍA ACTUAL, SE ESTAN RELLENANDO TIMESHEETS A TIEMPO FUTURO//
        public async Task AutoFillTimesheetsForInvestigatorsInSingleWPWithEffortAsync()
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "ProcesarInvestigadoresWP.txt");

            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            try
            {
                logger.Information("=== INICIO: Procesar investigadores en un único proyecto y paquete de trabajo (proyectos desde 2018) ===");

                // Filtrar investigadores en un único proyecto y único paquete de trabajo (WP) cuyos proyectos comienzan en 2018 o después
                var allWpxPeople = await _context.Wpxpeople
                    .Include(wpx => wpx.PersonNavigation)
                    .Include(wpx => wpx.WpNavigation)
                    .ThenInclude(wp => wp.Proj)
                    .Where(wpx =>
                        wpx.WpNavigation.Proj.Start.HasValue &&  // Verificar que el proyecto tiene fecha de inicio
                        wpx.WpNavigation.Proj.Start.Value.Year >= 2018 && // Incluir solo proyectos desde 2018
                        _context.Wpxpeople.Count(w => w.Person == wpx.Person) == 1 && // Solo en un único WP
                        _context.Projectxpeople.Count(p => p.Person == wpx.Person) == 1) // Solo en un único proyecto
                    .ToListAsync();

                if (!allWpxPeople.Any())
                {
                    logger.Information("No se encontraron investigadores que cumplan las condiciones. Finalizando proceso.");
                    return;
                }

                foreach (var wpxPerson in allWpxPeople)
                {
                    var personId = wpxPerson.Person;
                    var wpId = wpxPerson.Wp;
                    var projectId = wpxPerson.WpNavigation.Proj.ProjId;

                    logger.Information($"--- Procesando investigador: PersonId={personId}, WP={wpId}, Proyecto={projectId} ---");

                    // Obtener todos los esfuerzos asignados al WP de esta persona
                    var efforts = await _context.Persefforts
                        .Where(e => e.WpxPerson == wpxPerson.Id)
                        .ToListAsync();

                    foreach (var effort in efforts)
                    {
                        var year = effort.Month.Year;
                        var month = effort.Month.Month;

                        logger.Information($"--- Mes: {year}-{month:D2} ---");

                        // Validar effort
                        if (effort.Value <= 0)
                        {
                            logger.Warning($"PersonId={personId}, WP={wpId}, Mes={year}-{month:D2}: Effort es 0 o negativo. Omitiendo.");
                            continue;
                        }

                        // Calcular horas diarias máximas
                        var dailyWorkHours = await _workCalendarService.CalculateDailyWorkHoursWithDedication(personId, year, month);

                        // Obtener los días válidos del mes (excluyendo festivos y bajas)
                        var startDate = new DateTime(year, month, 1);
                        var endDate = new DateTime(year, month, DateTime.DaysInMonth(year, month));
                        var holidays = await _workCalendarService.GetHolidaysForMonth(year, month);
                        var leaveDays = await _workCalendarService.GetLeavesForPerson(personId, year, month);

                        var validDays = dailyWorkHours
                            .Where(dwh => !holidays.Contains(dwh.Key) && !leaveDays.Any(ld => ld.Day == dwh.Key))
                            .ToList();

                        if (!validDays.Any())
                        {
                            logger.Warning($"PersonId={personId}, WP={wpId}, Mes={year}-{month:D2}: No hay días válidos (festivos o bajas). Omitiendo.");
                            continue;
                        }

                        decimal totalEffort = effort.Value; // Effort mensual

                        foreach (var day in validDays)
                        {
                            var dayDate = day.Key;
                            var maxDailyHours = day.Value;

                            // Ajustar las horas diarias por el effort
                            decimal adjustedDailyHours =  (maxDailyHours * totalEffort);

                            if (adjustedDailyHours == 0)
                            {
                                logger.Debug($"PersonId={personId}, Día={dayDate:yyyy-MM-dd}: Sin horas ajustadas (Effort: {totalEffort:P}, Max: {maxDailyHours}h). Omitiendo.");
                                continue;
                            }

                            // Verificar si ya existe un registro para el día
                            var existingTimesheet = await _context.Timesheets
                                .FirstOrDefaultAsync(ts => ts.WpxPersonId == wpxPerson.Id && ts.Day == dayDate);

                            if (existingTimesheet != null)
                            {
                                // Actualizar registro existente
                                existingTimesheet.Hours = adjustedDailyHours;
                                _context.Timesheets.Update(existingTimesheet);
                                logger.Information($"Actualizado: PersonId={personId}, WP={wpId}, Proyecto={projectId}, Día={dayDate:yyyy-MM-dd}, Horas={adjustedDailyHours}.");
                            }
                            else
                            {
                                // Crear un nuevo registro
                                var newTimesheet = new Timesheet
                                {
                                    WpxPersonId = wpxPerson.Id,
                                    Day = dayDate,
                                    Hours = adjustedDailyHours
                                };
                                _context.Timesheets.Add(newTimesheet);
                                logger.Information($"Insertado: PersonId={personId}, WP={wpId}, Proyecto={projectId}, Día={dayDate:yyyy-MM-dd}, Horas={adjustedDailyHours}.");
                            }
                        }

                        logger.Information($"--- Fin de procesamiento para Mes: {year}-{month:D2} ---");
                    }

                    logger.Information($"--- Fin de procesamiento para investigador PersonId={personId}, WP={wpId} ---");
                }

                // Guardar cambios
                await _context.SaveChangesAsync();
                logger.Information("=== FIN: Proceso completado exitosamente ===");
            }
            catch (Exception ex)
            {
                logger.Error($"Error en el proceso: {ex.Message}");
                throw;
            }
            finally
            {
                logger.Dispose();
            }
        }


        public async Task AutoFillTimesheetsByDateRangeAsync(DateTime startDate, DateTime endDate)
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "AutoFillTimesheetsByDateRangeLog.txt");
            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            try
            {
                logger.Information($"Inicio del proceso AutoFillTimesheetsByDateRange para el rango {startDate:yyyy-MM} a {endDate:yyyy-MM}");

                for (var date = new DateTime(startDate.Year, startDate.Month, 1);
                     date <= new DateTime(endDate.Year, endDate.Month, 1);
                     date = date.AddMonths(1))
                {
                    var monthStart = new DateTime(date.Year, date.Month, 1);
                    var monthEnd = monthStart.AddMonths(1).AddDays(-1);

                    logger.Information($"Procesando el mes: {monthStart:yyyy-MM}");

                    var employees = await (from pf in _context.Persefforts
                                           join wxp in _context.Wpxpeople on pf.WpxPerson equals wxp.Id
                                           where pf.Value != 0 && pf.Month.Year == monthStart.Year && pf.Month.Month == monthStart.Month
                                           group pf by new { wxp.Person, pf.Month } into g
                                           where g.Count() == 1
                                           select new
                                           {
                                               Person = g.Key.Person,
                                               Month = g.Key.Month
                                           }).ToListAsync();

                    logger.Information($"Encontrados {employees.Count} investigadores con un único WP en el mes {monthStart:yyyy-MM}");

                    foreach (var employee in employees)
                    {
                        // ✅ Obtener la lista de WPs asignados a este empleado
                        var wpxList = await _context.Wpxpeople
                            .Include(w => w.PersonNavigation)
                            .Include(w => w.WpNavigation)
                                .ThenInclude(wp => wp.Proj)
                            .Where(w => w.Person == employee.Person)
                            .ToListAsync();

                        // ✅ Buscar el WP en el que tiene effort en este mes
                        var wpxWithEffort = await _context.Persefforts
                            .Where(pe => pe.Month == employee.Month && wpxList.Select(w => w.Id).Contains(pe.WpxPerson))
                            .Select(pe => pe.WpxPerson) // ✅ Solo tomamos los WpxPersonId que tienen effort
                            .FirstOrDefaultAsync();

                        if (wpxWithEffort == 0) // Si no encuentra ninguno, lo omitimos
                        {
                            _logger.LogWarning($"[Empleado {employee.Person}] No tiene effort en ninguno de sus WPs en {employee.Month:yyyy-MM}. Omitiendo.");
                            continue;
                        }

                        // ✅ Ahora obtenemos el objeto completo del WP correcto
                        var wpx = wpxList.FirstOrDefault(w => w.Id == wpxWithEffort);

                        if (wpx == null)
                        {
                            _logger.LogWarning($"[Empleado {employee.Person}] Error al obtener WP con effort en {employee.Month:yyyy-MM}. Omitiendo.");
                            continue;
                        }

                        try
                        {   
                            var personName = wpx.PersonNavigation.Name ?? "SIN NOMBRE";
                            var personSurname = wpx.PersonNavigation.Surname ?? "SIN APELLIDO";
                            var projectAcronym = wpx.WpNavigation?.Proj?.Acronim ?? "SIN PROYECTO";

                            var monthlyEffort = await _context.Persefforts
                                .Where(pe => pe.WpxPerson == wpx.Id && pe.Month.Year == monthStart.Year && pe.Month.Month == monthStart.Month)
                                .SumAsync(pe => pe.Value);

                            if (monthlyEffort <= 0)
                            {
                                logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: Effort es 0 o negativo. Omitiendo.");
                                continue;
                            }

                            var maxEffortForMonth = await _context.PersMonthEfforts
                                .Where(pme => pme.PersonId == wpx.Person && pme.Month.Year == monthStart.Year && pme.Month.Month == monthStart.Month)
                                .Select(pme => pme.Value)
                                .FirstOrDefaultAsync();

                            // **🔹 Corregir Effort Erróneo**
                            if (monthlyEffort > maxEffortForMonth)
                            {
                                logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: Effort incorrecto ({monthlyEffort}), ajustado a {maxEffortForMonth}.");
                                monthlyEffort = maxEffortForMonth;
                            }

                            bool ajusteCompleto = Math.Abs((decimal)monthlyEffort - (decimal)maxEffortForMonth) <= 0.001m;
                            string tipoAjuste = ajusteCompleto ? "AJUSTE COMPLETO" : "AJUSTE INCOMPLETO";

                            var validWorkDays = new List<DateTime>();
                            for (var day = monthStart; day <= monthEnd; day = day.AddDays(1))
                            {
                                if (day.DayOfWeek == DayOfWeek.Saturday || day.DayOfWeek == DayOfWeek.Sunday) continue;
                                if (await _workCalendarService.IsHoliday(day)) continue;
                                validWorkDays.Add(day);
                            }

                            var leaveDays = await _context.Leaves
                                .Where(l => l.PersonId == wpx.Person && l.Day >= monthStart && l.Day <= monthEnd && (l.Type == 1 || l.Type == 2 || l.Type == 3))
                                .Select(l => l.Day)
                                .ToListAsync();

                            validWorkDays = validWorkDays.Except(leaveDays).ToList();

                            if (validWorkDays.Count == 0)
                            {
                                logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: No hay días hábiles después de bajas. Omitiendo.");
                                continue;
                            }

                            var maxHoursForMonth = await _workCalendarService.CalculateMaxHoursForPersonInMonth(wpx.Person, monthStart.Year, monthStart.Month);

                            
                            // **🔹 Selección de método de cálculo**
                            decimal totalMonthlyHours;
                            if (ajusteCompleto)
                            {
                                totalMonthlyHours = maxHoursForMonth * maxEffortForMonth; // Método tradicional
                            }
                            else
                            {
                                totalMonthlyHours = monthlyEffort * maxHoursForMonth; // Regla de 3
                            }

                            // **🔹 Repartir las horas entre los días válidos**
                            var rawDailyHours = totalMonthlyHours / validWorkDays.Count;

                            // **🔹 Redondear a múltiplos de 0.5**
                            var adjustedDailyHours = Math.Round(rawDailyHours * 2, MidpointRounding.AwayFromZero) / 2;

                            if (adjustedDailyHours == 0) adjustedDailyHours = 0.5m;

                            logger.Information($"[{personName} {personSurname}] [{projectAcronym}] - {tipoAjuste} - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: TotalHoras={totalMonthlyHours}, Días Laborables={validWorkDays.Count}, Horas/día={adjustedDailyHours}");

                            foreach (var day in validWorkDays)
                            {
                                var existingTimesheet = await _context.Timesheets
                                    .FirstOrDefaultAsync(ts => ts.WpxPersonId == wpx.Id && ts.Day == day);

                                if (existingTimesheet == null)
                                {
                                    _context.Timesheets.Add(new Timesheet
                                    {
                                        WpxPersonId = wpx.Id,
                                        Day = day,
                                        Hours = adjustedDailyHours
                                    });

                                    logger.Information($"[{personName} {personSurname}] [{projectAcronym}] - {tipoAjuste} - Creado registro de Timesheet en {day:yyyy-MM-dd} con {adjustedDailyHours:F2} horas");
                                }
                                else
                                {
                                    decimal horasPrevias = existingTimesheet.Hours;
                                    existingTimesheet.Hours = adjustedDailyHours;

                                    logger.Information($"[{personName} {personSurname}] [{projectAcronym}] - {tipoAjuste} - Actualizado registro de Timesheet en {day:yyyy-MM-dd}. Antes: {horasPrevias:F2} horas, Ahora: {adjustedDailyHours:F2} horas");
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            logger.Error($"Error procesando [{wpx.PersonNavigation.Name} {wpx.PersonNavigation.Surname}] [{wpx.WpNavigation.Proj.Acronim}] - WP {wpx.Wp} en {monthStart:yyyy-MM}: {ex.Message}");
                        }
                    }

                    await _context.SaveChangesAsync();
                    logger.Information($"Finalizado procesamiento para el mes {monthStart:yyyy-MM}");
                }
            }
            catch (Exception ex)
            {
                logger.Error($"Error general en AutoFillTimesheetsByDateRange: {ex.Message}");
            }

            finally
            {
                logger.Dispose();
            }
        }

        public async Task AutoFillTimesheetForPersonAndMonthAsync(int personId, DateTime targetMonth)
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", $"AutoFillTimesheet_{personId}_{targetMonth:yyyyMM}.txt");
            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Infinite)
                .CreateLogger();

            try
            {
                var monthStart = new DateTime(targetMonth.Year, targetMonth.Month, 1);
                var monthEnd = monthStart.AddMonths(1).AddDays(-1);

                logger.Information($"Inicio del proceso para el empleado {personId} en el mes {monthStart:yyyy-MM}");

                var wpxList = await _context.Wpxpeople
                    .Include(w => w.PersonNavigation)
                    .Include(w => w.WpNavigation)
                        .ThenInclude(wp => wp.Proj)
                    .Where(w => w.Person == personId)
                    .ToListAsync();

                var wpxWithEffort = await _context.Persefforts
                    .Where(pe => pe.Month == monthStart && wpxList.Select(w => w.Id).Contains(pe.WpxPerson))
                    .Select(pe => pe.WpxPerson)
                    .FirstOrDefaultAsync();

                if (wpxWithEffort == 0)
                {
                    logger.Warning($"Empleado {personId} no tiene effort registrado en {monthStart:yyyy-MM}");
                    return;
                }

                var wpx = wpxList.FirstOrDefault(w => w.Id == wpxWithEffort);
                if (wpx == null)
                {
                    logger.Warning($"Error al obtener WP con effort para el empleado {personId} en {monthStart:yyyy-MM}");
                    return;
                }

                var personName = wpx.PersonNavigation.Name ?? "SIN NOMBRE";
                var personSurname = wpx.PersonNavigation.Surname ?? "SIN APELLIDO";
                var projectAcronym = wpx.WpNavigation?.Proj?.Acronim ?? "SIN PROYECTO";

                var monthlyEffort = await _context.Persefforts
                    .Where(pe => pe.WpxPerson == wpx.Id && pe.Month == monthStart)
                    .SumAsync(pe => pe.Value);

                if (monthlyEffort <= 0)
                {
                    logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: Effort es 0 o negativo");
                    return;
                }

                var maxEffort = await _context.PersMonthEfforts
                    .Where(pme => pme.PersonId == personId && pme.Month == monthStart)
                    .Select(pme => pme.Value)
                    .FirstOrDefaultAsync();

                if (monthlyEffort > maxEffort)
                {
                    logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: Ajuste de {monthlyEffort} a {maxEffort}");
                    monthlyEffort = maxEffort;
                }

                bool ajusteCompleto = Math.Abs(monthlyEffort - maxEffort) <= 0.001m;

                var validWorkDays = Enumerable.Range(0, (monthEnd - monthStart).Days + 1)
                    .Select(offset => monthStart.AddDays(offset))
                    .Where(day => day.DayOfWeek != DayOfWeek.Saturday && day.DayOfWeek != DayOfWeek.Sunday)
                    .ToList();

                validWorkDays = validWorkDays
                    .Where(day => !_workCalendarService.IsHoliday(day).Result)
                    .ToList();

                var leaveDays = await _context.Leaves
                    .Where(l => l.PersonId == personId && l.Day >= monthStart && l.Day <= monthEnd && (l.Type == 1 || l.Type == 2 || l.Type == 3))
                    .Select(l => l.Day)
                    .ToListAsync();

                validWorkDays = validWorkDays.Except(leaveDays).ToList();

                if (!validWorkDays.Any())
                {
                    logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - No hay días hábiles disponibles");
                    return;
                }

                var maxHoursForMonth = await _workCalendarService.CalculateMaxHoursForPersonInMonth(personId, monthStart.Year, monthStart.Month);

                decimal totalMonthlyHours = ajusteCompleto ? maxHoursForMonth * maxEffort : monthlyEffort * maxHoursForMonth;
                decimal rawDailyHours = totalMonthlyHours / validWorkDays.Count;
                decimal adjustedDailyHours = Math.Round(rawDailyHours * 2, MidpointRounding.AwayFromZero) / 2;
                if (adjustedDailyHours == 0) adjustedDailyHours = 0.5m;

                foreach (var day in validWorkDays)
                {
                    var timesheet = await _context.Timesheets
                        .FirstOrDefaultAsync(ts => ts.WpxPersonId == wpx.Id && ts.Day == day);

                    if (timesheet == null)
                    {
                        _context.Timesheets.Add(new Timesheet
                        {
                            WpxPersonId = wpx.Id,
                            Day = day,
                            Hours = adjustedDailyHours
                        });
                        logger.Information($"[{personName} {personSurname}] Día {day:yyyy-MM-dd}: nuevo registro con {adjustedDailyHours} horas");
                    }
                    else
                    {
                        decimal previous = timesheet.Hours;
                        timesheet.Hours = adjustedDailyHours;
                        logger.Information($"[{personName} {personSurname}] Día {day:yyyy-MM-dd}: actualizado de {previous} a {adjustedDailyHours} horas");
                    }
                }

                await _context.SaveChangesAsync();
                logger.Information($"Finalizado para el empleado {personId} en {monthStart:yyyy-MM}");
            }
            catch (Exception ex)
            {
                logger.Error($"Error en AutoFillTimesheetForPersonAndMonthAsync: {ex.Message}");
            }
            finally
            {
                logger.Dispose();
            }
        }


        public async Task<List<dynamic>> GetAdjustmentData(DateTime startDate, DateTime endDate)
        {
            var employeesToAdjust = new List<dynamic>();

            for (var date = new DateTime(startDate.Year, startDate.Month, 1);
                 date <= new DateTime(endDate.Year, endDate.Month, 1);
                 date = date.AddMonths(1))
            {
                var monthStart = new DateTime(date.Year, date.Month, 1);
                var monthEnd = monthStart.AddMonths(1).AddDays(-1);

                // Consulta LINQ traducida de SQL
                var employees = await (from pf in _context.Persefforts
                                       join wxp in _context.Wpxpeople on pf.WpxPerson equals wxp.Id
                                       where pf.Value != 0 && pf.Month.Year == monthStart.Year && pf.Month.Month == monthStart.Month
                                       group pf by new { wxp.Person, pf.Month } into g
                                       where g.Count() == 1
                                       select new
                                       {
                                           Person = g.Key.Person,
                                           Month = g.Key.Month
                                       }).ToListAsync();

                foreach (var employee in employees)
                {
                    try
                    {
                        var wpx = await _context.Wpxpeople
                            .Include(w => w.PersonNavigation)
                            .Include(w => w.WpNavigation)
                                .ThenInclude(wp => wp.Proj)
                            .FirstOrDefaultAsync(w => w.Person == employee.Person);

                        if (wpx == null) continue;

                        _logger.LogInformation($"🔍 Procesando persona {wpx.Person} - WP: {wpx.WpNavigation?.Name ?? "SIN WP"}");

                        var monthlyEffort = await _context.Persefforts
                            .Where(pe => pe.WpxPerson == wpx.Id && pe.Month.Year == monthStart.Year && pe.Month.Month == monthStart.Month)
                            .SumAsync(pe => pe.Value);

                        var maxEffortForMonth = await _context.PersMonthEfforts
                            .Where(pme => pme.PersonId == wpx.Person && pme.Month.Year == monthStart.Year && pme.Month.Month == monthStart.Month)
                            .Select(pme => pme.Value)
                            .FirstOrDefaultAsync();

                        var workingDays = await _workCalendarService.CalculateWorkingDays(monthStart.Year, monthStart.Month);
                        var leaveDays = await _context.Leaves
                            .Where(l => l.PersonId == wpx.Person && l.Day >= monthStart && l.Day <= monthEnd && (l.Type == 1 || l.Type == 2))
                            .Select(l => l.Day)
                            .ToListAsync();

                        var effectiveWorkingDays = workingDays - leaveDays.Count;
                        bool willBeAdjusted = Math.Abs((decimal)monthlyEffort - (decimal)maxEffortForMonth) < 0.001m;

                        // Obtener el nombre del Departamento
                        var departmentName = await _context.Departments
                            .Where(d => d.Id == _context.Personnel
                                .Where(p => p.Id == wpx.Person)
                                .Select(p => p.Department)
                                .FirstOrDefault())
                            .Select(d => d.Name)
                            .FirstOrDefaultAsync() ?? "SIN DEPARTAMENTO";

                        // Obtener el nombre del Grupo de Personal
                        var groupName = await _context.Personnelgroups
                            .Where(g => g.Id == _context.Personnel
                                .Where(p => p.Id == wpx.Person)
                                .Select(p => p.PersonnelGroup)
                                .FirstOrDefault())
                            .Select(g => g.GroupName)
                            .FirstOrDefaultAsync() ?? "SIN GRUPO";

                        // Marcar empleados que NO tienen el mes completo
                        string estado = willBeAdjusted ? "Sí" : "No (Requiere Ajuste)";

                        employeesToAdjust.Add(new
                        {
                            PersonId = wpx.Person,
                            Nombre = wpx.PersonNavigation?.Name ?? "SIN NOMBRE",
                            Apellido = wpx.PersonNavigation?.Surname ?? "SIN APELLIDO",
                            Departamento = departmentName,
                            Grupo = groupName,
                            Mes = monthStart.ToString("yyyy-MM"),
                            WorkPackage = wpx.WpNavigation?.Name ?? "SIN WP",
                            Proyecto = wpx.WpNavigation?.Proj?.Acronim ?? "SIN PROYECTO",
                            EffortAsignado = monthlyEffort,
                            EffortEsperado = maxEffortForMonth,
                            DiasLaborables = workingDays,
                            DiasAjustados = effectiveWorkingDays,
                            AjustadoAutomaticamente = estado
                        });

                        _logger.LogInformation($"✅ Ajuste agregado para {wpx.Person}");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError($"❌ Error procesando persona: {ex.Message} - {ex.StackTrace}");
                    }
                }
            }

            return employeesToAdjust;
        }








        // Método auxiliar para redondear al entero o .5 más cercano
        private decimal RoundToNearestHalfOrWhole(decimal value)
        {
            return Math.Round(value * 2, MidpointRounding.AwayFromZero) / 2;
        }

        public async Task OutOfContractLoadAsync()
        {
            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "OutOfContractLoadLog.txt");
            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            try
            {
                logger.Information("=== INICIO: Proceso de carga de días fuera de contrato ===");

                // Eliminar todos los registros existentes de tipo 3
                logger.Information("Eliminando registros existentes de tipo 3 en la tabla Leave...");
                var deletedCount = await _context.Database.ExecuteSqlRawAsync("DELETE FROM Leave WHERE Type = 3");
                logger.Information($"Eliminados {deletedCount} registros previos de días fuera de contrato.");

                // Obtener todos los contratos de las personas
                logger.Information("Cargando contratos de todas las personas...");
                var allContracts = await _context.Dedications
                    .Where(d => d.Type == 0)
                    .OrderBy(d => d.PersId)                    
                    .ThenBy(d => d.Start)
                    .ToListAsync();

                var groupedContracts = allContracts
                    .GroupBy(c => c.PersId)
                    .ToList();

                logger.Information($"Procesando un total de {groupedContracts.Count} personas con contratos registrados.");

                var newLeaves = new List<Leave>();

                foreach (var contractGroup in groupedContracts)
                {
                    var personId = contractGroup.Key;
                    var contracts = contractGroup.ToList();
                    logger.Information($"Procesando contratos para PersonId={personId}. Total contratos={contracts.Count}");

                    // Detectar días fuera de contrato entre contratos múltiples
                    for (int i = 0; i < contracts.Count - 1; i++)
                    {
                        var currentEnd = contracts[i].End;
                        var nextStart = contracts[i + 1].Start;

                        if (currentEnd.AddDays(1) < nextStart)
                        {
                            // Rango de días fuera de contrato
                            var gapStart = currentEnd.AddDays(1);
                            var gapEnd = nextStart.AddDays(-1);

                            logger.Information($"PersonId={personId}: Días fuera de contrato detectados entre {gapStart:yyyy-MM-dd} y {gapEnd:yyyy-MM-dd}");

                            for (var day = gapStart; day <= gapEnd; day = day.AddDays(1))
                            {
                                if (!newLeaves.Any(l => l.PersonId == personId && l.Day == day))
                                {
                                    newLeaves.Add(new Leave
                                    {
                                        PersonId = personId,
                                        Day = day,
                                        Type = 3,
                                        Legacy = false,
                                        LeaveReduction = 1,
                                        Hours = null
                                    });
                                    logger.Debug($"Preparado para insertar: PersonId={personId}, Día={day:yyyy-MM-dd}");
                                }
                            }
                        }
                    }

                    // Manejar contratos únicos que no cubren el mes completo
                    var firstContract = contracts.First();
                    var lastContract = contracts.Last();

                    // Completar días antes del inicio del primer contrato
                    if (firstContract.Start.Day > 1)
                    {
                        var startOfMonth = new DateTime(firstContract.Start.Year, firstContract.Start.Month, 1);
                        for (var day = startOfMonth; day < firstContract.Start; day = day.AddDays(1))
                        {
                            if (!newLeaves.Any(l => l.PersonId == personId && l.Day == day))
                            {
                                newLeaves.Add(new Leave
                                {
                                    PersonId = personId,
                                    Day = day,
                                    Type = 3,
                                    Legacy = false,
                                    LeaveReduction = 1,
                                    Hours = null
                                });
                                logger.Debug($"Preparado para insertar: PersonId={personId}, Día={day:yyyy-MM-dd}");
                            }
                        }
                    }

                    // Completar días después del fin del último contrato
                    var endOfMonth = new DateTime(lastContract.End.Year, lastContract.End.Month, DateTime.DaysInMonth(lastContract.End.Year, lastContract.End.Month));
                    if (lastContract.End < endOfMonth)
                    {
                        for (var day = lastContract.End.AddDays(1); day <= endOfMonth; day = day.AddDays(1))
                        {
                            if (!newLeaves.Any(l => l.PersonId == personId && l.Day == day))
                            {
                                newLeaves.Add(new Leave
                                {
                                    PersonId = personId,
                                    Day = day,
                                    Type = 3,
                                    Legacy = false,
                                    LeaveReduction = 1,
                                    Hours = null
                                });
                                logger.Debug($"Preparado para insertar: PersonId={personId}, Día={day:yyyy-MM-dd}");
                            }
                        }
                    }
                }

                logger.Information($"Preparados {newLeaves.Count} registros para insertar.");

                // Insertar nuevos registros
                foreach (var leave in newLeaves)
                {
                    if (!await _context.Leaves.AnyAsync(l => l.PersonId == leave.PersonId && l.Day == leave.Day))
                    {
                        _context.Leaves.Add(leave);
                        logger.Debug($"Insertado: PersonId={leave.PersonId}, Día={leave.Day:yyyy-MM-dd}");
                    }
                    else
                    {
                        logger.Warning($"Duplicado evitado: PersonId={leave.PersonId}, Día={leave.Day:yyyy-MM-dd}");
                    }
                }

                // Guardar cambios en la base de datos
                await _context.SaveChangesAsync();
                logger.Information("=== FIN: Proceso completado exitosamente ===");
            }
            catch (Exception ex)
            {
                logger.Error($"Error en OutOfContractLoadAsync: {ex.Message}");

                if (ex.InnerException != null)
                {
                    logger.Error($"Inner Exception: {ex.InnerException.Message}");
                    logger.Error($"Stack Trace: {ex.InnerException.StackTrace}");
                }
                else
                {
                    logger.Error($"Stack Trace: {ex.StackTrace}");
                }

                throw;
            }
            finally
            {
                logger.Dispose();
            }
        }

        public async Task AdjustGlobalEffortAsync()
        {
            DateTime startDate = new DateTime(2025, 1, 1);
            DateTime endDate = new DateTime(2025, 12, 31);

            var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", "AdjustGlobalEffortLog.txt");
            var logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
                .CreateLogger();

            logger.Information("Inicio del proceso de ajuste global de esfuerzo");

            var projects = await _context.Projects
                .Where(p => (p.Start >= startDate && p.Start <= endDate) ||
                            (p.EndReportDate >= startDate && p.EndReportDate <= endDate))
                .Include(p => p.Wps)
                .ToListAsync();

            foreach (var project in projects)
            {
                var wpsWithPeople = project.Wps
                    .Where(wp => _context.Wpxpeople.Any(wpx => wpx.Wp == wp.Id))
                    .ToList();

                if (!wpsWithPeople.Any())
                {
                    continue;
                }

                logger.Information($"Procesando Proyecto: {project.Acronim} ({project.SapCode})");

                foreach (var wp in wpsWithPeople)
                {
                    logger.Information($"    - Work Package: {wp.Name} ({wp.Title})");

                    var people = await _context.Wpxpeople
                        .Where(wpx => wpx.Wp == wp.Id)
                        .Include(wpx => wpx.PersonNavigation)
                        .ToListAsync();

                    foreach (var person in people)
                    {
                        logger.Information($"        * Persona: {person.PersonNavigation.Name} {person.PersonNavigation.Surname}");

                        for (DateTime month = new DateTime(2020, 1, 1); month <= endDate; month = month.AddMonths(1))
                        {
                            logger.Information($"            - Procesando mes: {month:MMMM yyyy}");

                            var totalHoursInTimesheets = await _context.Timesheets
                                .Where(ts => ts.WpxPersonId == person.Id && ts.Day.Year == month.Year && ts.Day.Month == month.Month)
                                .SumAsync(ts => (decimal?)ts.Hours) ?? 0;

                            if (totalHoursInTimesheets == 0)
                            {
                                logger.Warning($"            - No hay horas registradas para este mes.");
                                continue;
                            }

                            decimal maxHours = await _workCalendarService.CalculateMaxHoursForPersonInMonth(person.Person, month.Year, month.Month);
                            if (maxHours == 0)
                            {
                                logger.Warning($"            - No se encontraron horas máximas definidas.");
                                continue;
                            }

                            decimal effortPercentage = totalHoursInTimesheets / maxHours;

                            var existingEffort = await _context.Persefforts
                                .FirstOrDefaultAsync(pe => pe.WpxPerson == person.Id && pe.Month.Year == month.Year && pe.Month.Month == month.Month);

                            if (existingEffort != null)
                            {
                                existingEffort.Value = effortPercentage;
                                _context.Persefforts.Update(existingEffort);
                            }
                            else
                            {
                                var newEffort = new Perseffort
                                {
                                    WpxPerson = person.Id,
                                    Month = new DateTime(month.Year, month.Month, 1),
                                    Value = effortPercentage
                                };
                                _context.Persefforts.Add(newEffort);
                            }

                            await _context.SaveChangesAsync();
                            logger.Information($"            - Esfuerzo ajustado al {effortPercentage:P2} para el mes {month:MMMM yyyy}.");
                        }
                    }
                }
            }

            logger.Information("Proceso de ajuste global de esfuerzo finalizado");
        }


        public async Task AdjustOverloadsFromDateAsync(DateTime startDate)
        {
            var persons = await _context.Personnel
                .Where(p => _context.Dedications.Any(c => c.Start <= startDate && c.End >= startDate))
                .ToListAsync(); // Personas con contrato activo

            foreach (var person in persons)
            {
                var monthsToCheck = await _context.PersMonthEfforts
                    .Where(pme => pme.PersonId == person.Id && pme.Month >= startDate)
                    .OrderBy(pme => pme.Month)
                    .ToListAsync(); // Solo meses desde la fecha definida

                foreach (var pme in monthsToCheck)
                {
                    if (await _workCalendarService.IsOverloadedAsync(person.Id, pme.Month.Year, pme.Month.Month))
                    {
                        var result = await _workCalendarService.AdjustMonthlyOverloadAsync(person.Id, pme.Month.Year, pme.Month.Month);

                        var status = result.Success ? "✅ OK" : $"❌ ERROR: {result.Message}";
                        _fileLogger.Information($"→ Persona {person.Id}, Mes {pme.Month:yyyy-MM}: {status}");
                    }
                }
            }
        }


        public async Task RunScheduledJobs()
        {
            var dataLoadPath = Path.Combine(Directory.GetCurrentDirectory(), "Dataload");

            _fileLogger.Information("🧹 Eliminando todos los registros de ejecuciones exitosas...");

            // 🔹 Eliminar TODOS los registros de ejecuciones exitosas
            var successLogs = _context.ProcessExecutionLogs
                .Where(p => p.Status == "Exitoso");

            int deletedCount = await successLogs.CountAsync();
            _context.ProcessExecutionLogs.RemoveRange(successLogs);
            await _context.SaveChangesAsync();

            _fileLogger.Information($"✅ {deletedCount} registros de ejecuciones exitosas eliminados.");

            var processes = new List<(string Name, Func<Task> Process)>
                            {
                                ("Carga de Proyectos", () => LoadProjectsFromFileAsync(Path.Combine(dataLoadPath, "PROJECTES.txt"))),
                                ("Carga de Grupos de Personal", () => LoadPersonnelGroupsFromFileAsync(Path.Combine(dataLoadPath, "GRUPS.txt"))),
                                ("Carga de Personal", () => LoadPersonnelFromFileAsync(Path.Combine(dataLoadPath, "PERSONAL.txt"))),
                                ("Carga de Líderes", () => LoadLeadersFromFileAsync(Path.Combine(dataLoadPath, "Leaders.txt"))),
                                ("Carga de Dedicaciones y Afiliaciones", () => LoadAffiliationsAndDedicationsFromFileAsync(Path.Combine(dataLoadPath, "DEDICACIO3.txt"))),
                                ("Carga de Out of Contract", () => OutOfContractLoadAsync()),
                                ("Carga de Liquidaciones", () => LoadLiquidationsFromFileAsync(Path.Combine(dataLoadPath, "Liquid.txt"))),
                                ("Procesamiento de Liquidaciones", () => ProcessLiquidationsAsync()),
                                ("Procesamiento Avanzado de Liquidaciones", () => ProcessAdvancedLiquidationsAsync()),
                                ("Actualización de Tabla de Ausencias", () => UpdateLeaveTableAsync()),
                                ("Carga de Esfuerzo Mensual", () => UpdateMonthlyPMs()),
                                ("Corrección de Overloads", () => AdjustOverloadsFromDateAsync(new DateTime(2025, 1, 1)))
                            };

            foreach (var (processName, process) in processes)
            {
                var executionLog = new ProcessExecutionLog
                {
                    ProcessName = processName,
                    ExecutionTime = DateTime.UtcNow
                };

                try
                {
                    _fileLogger.Information($"🔄 Iniciando proceso: {processName}");
                    var logFilePath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", $"{processName.Replace(" ", "")}.txt");
                    var previousLogLines = File.Exists(logFilePath) ? await File.ReadAllLinesAsync(logFilePath) : new string[0];

                    await process();

                    var newLogLines = File.Exists(logFilePath) ? await File.ReadAllLinesAsync(logFilePath) : new string[0];
                    var recentLogs = newLogLines.Except(previousLogLines)
                                                .Where(line => line.Contains("[Warning]") || line.Contains("[Error]"))
                                                .ToList();

                    if (recentLogs.Any(log => log.Contains("[Error]")))
                    {
                        executionLog.Status = "Fallido"; // 🔴 Rojo en la vista
                        executionLog.LogMessage = string.Join("\n", recentLogs.Where(log => log.Contains("[Error]")));
                    }
                    else if (recentLogs.Any(log => log.Contains("[Warning]")))
                    {
                        executionLog.Status = "Advertencias"; // 🟡 Amarillo en la vista
                        executionLog.LogMessage = string.Join("\n", recentLogs.Where(log => log.Contains("[Warning]")));
                    }
                    else
                    {
                        executionLog.Status = "Exitoso"; // ✅ Verde en la vista
                        executionLog.LogMessage = "Proceso completado sin incidencias.";
                    }
                }
                catch (Exception ex)
                {
                    executionLog.Status = "Fallido";
                    executionLog.LogMessage = ex.Message;
                    _fileLogger.Error($"Error en {processName}: {ex.Message}");
                }

                _context.ProcessExecutionLogs.Add(executionLog);
                await _context.SaveChangesAsync();
            }

            _fileLogger.Information("🎉 TODOS LOS PROCESOS SE HAN EJECUTADO CORRECTAMENTE.");
        }





        public async Task Execute(IJobExecutionContext context)
        {
                                    
            var dataMap = context.MergedJobDataMap;
            try { 
                // ✅ Verificamos si la clave "Action" existe antes de acceder a ella
                if (!dataMap.ContainsKey("Action"))
                {
                    _fileLogger.Information("⏳ Ejecutando `RunScheduledJobs()` porque Quartz no proporcionó una acción específica.");
                    await RunScheduledJobs();
                    _fileLogger.Information("✅ Finalizado `RunScheduledJobs()`.");
                    return;
                }

                var action = dataMap.GetString("Action");
                _fileLogger.Information($"🔄 Ejecutando acción específica: {action}");

                switch (action)
                {
                    case "UpdateMonthlyPMs":
                        await UpdateMonthlyPMs();
                        break;

                    case "LoadLiquidationsFromFile":
                        var filePath = dataMap.GetString("FilePath");
                        await LoadLiquidationsFromFileAsync(filePath);
                        break;

                    case "ProcessLiquidations":
                        await ProcessLiquidationsAsync();
                        break;

                    case "ProcessLiquidationsAdvanced":
                        await ProcessAdvancedLiquidationsAsync();
                        break;

                    case "LoadPersonnelFromFile":
                        var filePath2 = dataMap.GetString("FilePath");
                        await LoadPersonnelFromFileAsync(filePath2);
                        break;

                    case "LoadAffiliationsAndDedicationsFromFile":
                        var filePath3 = dataMap.GetString("FilePath");
                        await LoadAffiliationsAndDedicationsFromFileAsync(filePath3);
                        break;

                    case "LoadPersonnelGroupsFromFile":
                        var filePath4 = dataMap.GetString("FilePath");
                        await LoadPersonnelGroupsFromFileAsync(filePath4);
                        break;

                    case "LoadLeadersFromFile":
                        var filePath5 = dataMap.GetString("FilePath");
                        await LoadLeadersFromFileAsync(filePath5);
                        break;

                    case "LoadProjectsFromFile":
                        var filePath6 = dataMap.GetString("FilePath");
                        await LoadProjectsFromFileAsync(filePath6);
                        break;

                    case "FetchAndSaveAgreementEvents":
                        await FetchAndSaveAgreementEventsAsync();
                        break;

                    case "UpdatePersonnelUserIds":
                        await UpdatePersonnelUserIdsAsync();
                        break;

                    case "UpdateLeaveTable":
                        await UpdateLeaveTableAsync();
                        break;

                    case "ProcessInvestigatorsTimesheet":
                        await AutoFillTimesheetsForInvestigatorsInSingleWPWithEffortAsync();
                        break;

                    case "LoadOutOfContract":
                        await OutOfContractLoadAsync();
                        break;

                    case "AdjustGlobalEffort":
                        await AdjustGlobalEffortAsync();
                        break;

                    case "AdjustEffortOverloads":
                        var cutoffDate = new DateTime(2025, 1, 1); // ⚠️ Fecha pendiente de acordar con Finanzas
                        await AdjustOverloadsFromDateAsync(cutoffDate);
                        break;

                    default:
                        _logger.LogError($"❌ Acción desconocida: {action}");
                        throw new ArgumentException("Acción no implementada para este trabajo.");
                }

                _logger.LogInformation($"✅ Acción `{action}` ejecutada correctamente.");
            }
            catch (Exception ex)
            {
                _fileLogger.Error($"❌ Error en la ejecución: {ex.Message}");
                throw;
            }            
        }
    }
}






----- FILE: C:\Users\premo\source\repos\trs3.0nuevo\TRS2.0\Services\ReminderEmailOptions.cs -----
namespace TRS2._0.Services
{
    public class ReminderEmailOptions
    {
        public string? ReplyTo { get; set; }
        public string? FromDisplayName { get; set; }
        public bool UseAssignmentCap { get; set; } = false;
    }
}



----- FILE: C:\Users\premo\source\repos\trs3.0nuevo\TRS2.0\Services\ReminderService.cs -----
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TRS2._0.Models.DataModels;
using Microsoft.Extensions.Options;

namespace TRS2._0.Services
{
    public class ReminderService
    {
        private readonly TRSDBContext _context;
        private readonly WorkCalendarService _workCalendarService;
        private readonly IEmailSender _emailSender;
        private readonly ILogger<ReminderService> _logger;
        private readonly LoadDataService _loadDataService;
        private readonly ReminderEmailOptions _options; 

        private const string TrsAppUrl = "https://opstrs03.bsc.es/Account/Login"; // del manual
        private const string GuidePdfPath = "wwwroot/docs/BSC_TRS_Guide_v1.pdf"; // coloca el PDF aquí en tu app
        private const string GuidePdfContentType = "application/pdf";


        public ReminderService(
            TRSDBContext context,
            WorkCalendarService workCalendarService,
            IEmailSender emailSender,
            ILogger<ReminderService> logger,
            LoadDataService loadDataService,
            IOptions<ReminderEmailOptions> options)
        {
            _context = context;
            _workCalendarService = workCalendarService;
            _emailSender = emailSender;
            _logger = logger;
            _loadDataService = loadDataService;
            _options = options.Value;
        }

        // ====== ENTRADA PRINCIPAL (llamada desde el Job) ======
        public async Task SendTimesheetRemindersAsync(bool firstMondayOfMonth)
        {
            // Siempre se trabaja con el MES ANTERIOR
            var today = DateTime.Today;
            int year = (today.Month == 1) ? today.Year - 1 : today.Year;
            int prevMonth = (today.Month == 1) ? 12 : today.Month - 1;
            var targetMonth = new DateTime(year, prevMonth, 1);

            if (firstMondayOfMonth)
            {
                await SendInitialMonthlyEmailToAllAsync(targetMonth);
            }
            else
            {
                await SendReminderToPendingUsersAsync(targetMonth);
            }
        }

        // ====== 2.1) PRIMER LUNES: INICIAL A TODO EL MUNDO + ADJUNTO ======
        private async Task SendInitialMonthlyEmailToAllAsync(DateTime targetMonth)
        {
            var today = DateTime.Today; // fecha de envío
            var cutoffFirstOfCurrentMonth = new DateTime(today.Year, today.Month, 1);

            // Solo personas con email y contrato ACTIVO hoy
            var personnelList = await _context.Personnel
                .Where(p => !string.IsNullOrEmpty(p.Email) &&
                            _context.Dedications.Any(d =>
                                d.PersId == p.Id &&
                                d.Start <= today &&
                                d.End >= today))
                .Select(p => new { p.Id, p.Email })
                .ToListAsync();

            var subject = "ACTION REQUIRED – Monthly Completion and Validation of Your TIMESHEET";

            foreach (var person in personnelList)
            {
                try
                {
                    // Meses pendientes: año >= 2025, effort>0 en WP activo, required-threshold>0 y declared<threshold
                    var pendingMonths = await GetPendingMonthsAsync(person.Id, cutoffFirstOfCurrentMonth);
                    if (pendingMonths.Count == 0) continue;

                    var body = BuildInitialEmailBodyHtml(pendingMonths);

                    await SendEmailWithGuideAsync(person.Email, subject, body);
                    _logger.LogInformation("[INITIAL] Email enviado a {Email}", person.Email);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "[INITIAL] Error enviando email a {Email}", person.Email);
                }
            }
        }




        // ====== 2.2) LUNES SIGUIENTES: RECORDATORIO SOLO A PENDIENTES ======
        private async Task SendReminderToPendingUsersAsync(DateTime targetMonth)
        {
            var today = DateTime.Today; // fecha de envío

            // Solo personas con email y contrato ACTIVO hoy
            var personnelList = await _context.Personnel
                .Where(p => !string.IsNullOrEmpty(p.Email) &&
                            _context.Dedications.Any(d =>
                                d.PersId == p.Id &&
                                d.Start <= today &&
                                d.End >= today))
                .Select(p => new { p.Id, p.Name, p.Email })
                .ToListAsync();

            foreach (var person in personnelList)
            {
                try
                {
                    // Debe tener assignment + effort>0 en WP activo ese mes
                    var assignedWithEffort = await HasActiveAssignmentWithEffortAsync(
                        person.Id, targetMonth.Year, targetMonth.Month);

                    if (!assignedWithEffort)
                    {
                        _logger.LogInformation("[REMINDER] Saltado {Email}: sin asignación+effort en {Month:MM/yyyy}",
                            person.Email, targetMonth);
                        continue;
                    }

                    // HORAS declaradas
                    var declaredDict = await _workCalendarService
                        .GetDeclaredHoursPerMonthForPerson(person.Id, targetMonth, targetMonth);
                    declaredDict.TryGetValue(targetMonth, out decimal declaredHours);

                    // HORAS requeridas base (dedicación, festivos, bajas…)
                    var dailyHours = await _workCalendarService
                        .CalculateDailyWorkHoursWithDedicationAndLeaves(person.Id, targetMonth.Year, targetMonth.Month);
                    var requiredHoursBase = dailyHours.Values.Sum();

                    // Umbral final (aplica "cap" si el flag está ON)
                    var requiredThreshold = await GetRequiredThresholdAsync(
                        person.Id, targetMonth.Year, targetMonth.Month, requiredHoursBase);

                    // Si el umbral resultante es 0 (sin asignación utilizable), no avisamos
                    if (requiredThreshold <= 0m)
                    {
                        _logger.LogInformation("[REMINDER] Saltado {Email}: threshold=0 (sin asignación utilizable) en {Month:MM/yyyy}",
                            person.Email, targetMonth);
                        continue;
                    }

                    if (_options.UseAssignmentCap)
                    {
                        var assigned = await GetAssignedFractionAsync(person.Id, targetMonth.Year, targetMonth.Month);
                        _logger.LogInformation("[REMINDER][CAP] {Email} {Month:MM/yyyy} requiredBase={Base}h assigned={Assigned:P0} threshold={Threshold}h declared={Declared}h",
                            person.Email, targetMonth, requiredHoursBase, assigned, requiredThreshold, declaredHours);
                    }

                    var stillIncomplete = declaredHours < requiredThreshold;
                    if (!stillIncomplete) continue;

                    var subject = $"Reminder: Timesheet pending for {targetMonth:MMMM yyyy}";
                    var body = BuildTimesheetFocusedReminderEmail(
                        person.Name, targetMonth.ToString("MMMM yyyy"), declaredHours, requiredThreshold);

                    // Adjunta guía también en los recordatorios semanales (con Reply-To configurado)
                    await SendEmailWithGuideAsync(person.Email, subject, body);

                    _logger.LogInformation("[REMINDER] Email enviado a {Email}", person.Email);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "[REMINDER] Error evaluando/enviando a {Email}", person.Email);
                }
            }
        }




        public async Task SendTimesheetRemindersToSingleUserAsync(int personId, bool firstWeekOfMonth)
        {
            var person = await _context.Personnel.FirstOrDefaultAsync(p => p.Id == personId);
            if (person == null) return;

            var today = DateTime.Today;
            int year = today.Month == 1 ? today.Year - 1 : today.Year;
            int previousMonth = today.Month == 1 ? 12 : today.Month - 1;
            var targetMonth = new DateTime(year, previousMonth, 1);

            if (firstWeekOfMonth)
            {
                var cutoff = new DateTime(today.Year, today.Month, 1);
                var pendingMonths = await GetPendingMonthsAsync(person.Id, cutoff);
                if (!pendingMonths.Any()) return;

                var body = BuildInitialEmailBodyHtml(pendingMonths);
                var subject = "TEST - ACTION REQUIRED – Monthly Completion and Validation of Your TIMESHEET";

                await SendEmailWithGuideAsync(person.Email, subject, body, "david.reyes@bsc.es");
                _logger.LogInformation("[TEST-INITIAL] Email de prueba enviado a {Email}", person.Email);
                return;
            }
            else
            {
                var declared = await _workCalendarService
                    .GetDeclaredHoursPerMonthForPerson(person.Id, targetMonth, targetMonth);
                declared.TryGetValue(targetMonth, out decimal declaredHours);

                // Usa el mismo cálculo base que el reminder masivo
                var dailyHours = await _workCalendarService
                    .CalculateDailyWorkHoursWithDedicationAndLeaves(person.Id, targetMonth.Year, targetMonth.Month);
                var requiredHoursBase = dailyHours.Values.Sum();

                var requiredThreshold = await GetRequiredThresholdAsync(
                    person.Id, targetMonth.Year, targetMonth.Month, requiredHoursBase);

                if (requiredThreshold > 0m && declaredHours < requiredThreshold)
                {
                    var body = BuildTimesheetFocusedReminderEmail(
                        person.Name, targetMonth.ToString("MMMM yyyy"), declaredHours, requiredThreshold);

                    await SendEmailWithGuideAsync(
                        person.Email, $"TEST - Reminder for {targetMonth:MMMM yyyy}", body, "david.reyes@bsc.es");

                    _logger.LogInformation("[TEST-REMINDER] Email focalizado de prueba enviado a {Email}", person.Email);
                }
                else
                {
                    _logger.LogInformation("[TEST-REMINDER] No se envía: declared={Declared}h, threshold={Threshold}h",
                        declaredHours, requiredThreshold);
                }
            }
        }

        public record ReminderCandidate(
    int PersonId,
    string PersonName,
    string Email,
    DateTime TargetMonth,
    decimal DeclaredHours,
    decimal RequiredBaseHours,
    decimal AssignedFraction,
    decimal RequiredThresholdHours,
    bool WillSend
);

        public async Task<List<ReminderCandidate>> ComputeWeeklyReminderCandidatesAsync(
    DateTime targetMonth,
    bool onlyWillSend)
        {
            var all = await ComputeWeeklyReminderCandidatesAsync(targetMonth); // tu método actual
            return onlyWillSend ? all.Where(x => x.WillSend).ToList() : all;
        }



        /// <summary>
        /// Dry-run del recordatorio semanal para un mes objetivo (normalmente el mes anterior).
        /// NO envía emails. Devuelve la lista de candidatos y el motivo.
        /// </summary>
        public async Task<List<ReminderCandidate>> ComputeWeeklyReminderCandidatesAsync(DateTime targetMonth)
        {
            var results = new List<ReminderCandidate>();
            var today = DateTime.Today; // la regla es "contrato activo en el día del envío"

            // Solo candidatos con email; el filtro de contrato lo aplicamos por persona (evita subqueries pesadas en la lista)
            var personnelList = await _context.Personnel
                .Where(p => !string.IsNullOrEmpty(p.Email))
                .Select(p => new { p.Id, p.Name, p.Email })
                .ToListAsync();

            foreach (var person in personnelList)
            {
                try
                {
                    //  Si no tiene contrato ACTIVO hoy, ni lo evaluamos: no se envía
                    var hasContractToday = await IsContractActiveAsync(person.Id, today);
                    if (!hasContractToday)
                    {
                        results.Add(new ReminderCandidate(
                            person.Id, person.Name, person.Email, targetMonth,
                            DeclaredHours: 0m,
                            RequiredBaseHours: 0m,
                            AssignedFraction: 0m,
                            RequiredThresholdHours: 0m,
                            WillSend: false
                        ));
                        continue;
                    }


                    // ¿Tiene asignación activa con effort>0 ese mes?
                    var assignedWithEffort = await HasActiveAssignmentWithEffortAsync(
                        person.Id, targetMonth.Year, targetMonth.Month);

                    if (!assignedWithEffort)
                    {
                        results.Add(new ReminderCandidate(
                            person.Id, person.Name, person.Email, targetMonth,
                            DeclaredHours: 0m,
                            RequiredBaseHours: 0m,
                            AssignedFraction: 0m,
                            RequiredThresholdHours: 0m,
                            WillSend: false
                        ));
                        continue;
                    }

                    // Declaradas
                    var declaredDict = await _workCalendarService
                        .GetDeclaredHoursPerMonthForPerson(person.Id, targetMonth, targetMonth);
                    declaredDict.TryGetValue(targetMonth, out decimal declaredHours);

                    // Requeridas base
                    var dailyHours = await _workCalendarService
                        .CalculateDailyWorkHoursWithDedicationAndLeaves(person.Id, targetMonth.Year, targetMonth.Month);
                    var requiredBase = dailyHours.Values.Sum();

                    // Fracción asignada y umbral
                    var assignedFraction = _options.UseAssignmentCap
                        ? await GetAssignedFractionAsync(person.Id, targetMonth.Year, targetMonth.Month)
                        : 1m;

                    var requiredThreshold = await GetRequiredThresholdAsync(
                        person.Id, targetMonth.Year, targetMonth.Month, requiredBase);

                    // Reglas finales
                    bool willSend = requiredThreshold > 0m && declaredHours < requiredThreshold;

                    results.Add(new ReminderCandidate(
                        person.Id, person.Name, person.Email, targetMonth,
                        DeclaredHours: declaredHours,
                        RequiredBaseHours: requiredBase,
                        AssignedFraction: assignedFraction,
                        RequiredThresholdHours: requiredThreshold,
                        WillSend: willSend
                    ));
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "[DRYRUN] Error evaluando {Email}", person.Email);
                }
            }

            return results
                .OrderByDescending(r => r.WillSend)
                .ThenBy(r => r.PersonName)
                .ToList();
        }




        private string BuildTimesheetGeneralReminderEmail(string name, List<string> pending)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"<p>Hi {name},</p>");
            sb.AppendLine("<p>This is a friendly reminder to complete your timesheets for the following months:</p><ul>");
            pending.ForEach(p => sb.AppendLine($"<li>{p}</li>"));
            sb.AppendLine("</ul><p>Thank you.</p>");
            return sb.ToString();
        }

        private string BuildTimesheetFocusedReminderEmail(string name, string monthName, decimal declared, decimal requiredThreshold)
        {
            return $@"
        <p>Hi {name},</p>
        <p>Our records show that your timesheet for <strong>{monthName}</strong> is not yet complete.</p>
        <p>Declared hours: {declared}h / Required: {requiredThreshold}h</p>
        <p>Please complete it as soon as possible.</p>
        <p>Thank you.</p>";
        }


        // ====== 2.4) PLANTILLAS HTML ======
        private string BuildInitialEmailBodyHtml()
        {
            // Basado en “email INICIAL TRS VF” + enlace a TRS y nota de adjunto.
            // (los <br> son para compactarlo en un string)
            return $@"
            <p><strong>ACTION REQUIRED – Monthly Completion and Validation of Your TIMESHEET</strong></p>
            <p>Dear all,</p>
            <p>As a BSC member, you are required to complete and validate your working hours each month for the projects you are involved in. This process is essential for project financial reporting.</p>
            <p>Starting now, this process must be done personally through the new BSC Time Recording System App.</p>
            <p>⏰ You will receive an automatic reminder every Monday if your timesheet for the previous month has not been completed.</p>
            <p><strong>Important information:</strong></p>
            <ul>
              <li>Upon logging into the platform, the system will automatically record your access date.</li>
              <li>Make sure to click the “Save All” button to successfully complete and confirm your hours.</li>
              <li>It's fundamental that you track your holidays and leaves in Woffu because this system gets that data from Woffu database. Woffu does not track the assignment to projects.</li>
            </ul>
            <p>⚠️ Please note:<br/>A detailed user guide is attached to this email for your reference.</p>
            <p>👉 <a href=""{TrsAppUrl}"">Click here to access the TRS App</a></p>
            <p>Thank you for your cooperation.<br/>Best regards,<br/>Finance Projects Team</p>";
        }

        private string BuildInitialEmailBodyHtml(List<(DateTime Month, decimal Declared, decimal Required)> pending)
        {
            // Lista en HTML de los meses pendientes “Mes yyyy: Xh / Yh”
            var sbList = new StringBuilder();
            sbList.Append("<ul>");
            foreach (var (Month, Declared, Required) in pending.OrderBy(x => x.Month))
            {
                sbList.Append($"<li>{Month:MMMM yyyy}: {Declared}h / {Required}h</li>");
            }
            sbList.Append("</ul>");

            return $@"
                <p><strong>ACTION REQUIRED – Monthly Completion and Validation of Your TIMESHEET</strong></p>
                <p>Dear all,</p>
                <p>As a BSC member, you are required to complete and validate your working hours each month for the projects you are involved in. This process is essential for project financial reporting.</p>
                <p>Starting now, this process must be done personally through the new BSC Time Recording System App.</p>
                <p>⏰ You will receive an automatic reminder every Monday if your timesheet for the previous month has not been completed.</p>

                <p><strong>You currently have pending timesheets for:</strong></p>
                {sbList}

                <p><strong>Important information:</strong></p>
                <ul>
                  <li>Upon logging into the platform, the system will automatically record your access date.</li>
                  <li>Make sure to click the “Save All” button to successfully complete and confirm your hours.</li>
                  <li>It's fundamental that you track your holidays and leaves in Woffu because this system gets that data from Woffu database. Woffu does not track the assignment to projects.</li>
                </ul>
                <p>⚠️ Please note:<br/>A detailed user guide is attached to this email for your reference.</p>
                <p>👉 <a href=""{TrsAppUrl}"">Click here to access the TRS App</a></p>
                <p>Thank you for your cooperation.<br/>Best regards,<br/>Finance Projects Team</p>";
        }

        private string BuildReminderEmailBodyHtml()
        {
            // Basado en “email recordatorio TRS”
            return $@"
            <p>Dear all,</p>
            <p>This is a friendly reminder to complete and validate your TIMESHEET for the previous month in the BSC Time Recording System App.</p>
            <p>As communicated previously, recording your working hours is mandatory for project financial reporting. Please make sure to:</p>
            <ul>
              <li>Log in to the TRS App.</li>
              <li>Enter and validate your hours for the previous month.</li>
              <li>Click “Save All” to confirm completion.</li>
            </ul>
            <p>⚠️ Kindly complete this process as soon as possible to ensure compliance with reporting requirements.</p>
            <p>👉 <a href=""{TrsAppUrl}"">Access the TRS App here</a></p>
            <p>Thank you for your prompt attention.<br/>Best regards,<br/>Finance Projects Team</p>";
        }

        
        // Devuelve la lista de meses < cutoff (primer día del mes actual) en los que declared < threshold (y threshold>0)
        private async Task<List<(DateTime Month, decimal Declared, decimal Pm)>> GetPendingMonthsAsync(
            int personId, DateTime cutoffFirstOfCurrentMonth)
        {
            var pending = new List<(DateTime, decimal, decimal)>();

            // Meses candidatos (anteriores al primer día del mes actual)
            var months = await _loadDataService.RelevantMonths(personId);

            foreach (var month in months
                .Where(m => m < cutoffFirstOfCurrentMonth && m.Year >= 2025)   // solo desde 2025 en adelante
                .OrderBy(m => m))
            {
                // Requisito: ese mes tuvo effort>0 en algún WP ACTIVO
                var hasEffortInActiveWp = await HasActiveAssignmentWithEffortAsync(personId, month.Year, month.Month);
                if (!hasEffortInActiveWp) continue;

                // HORAS requeridas base (según dedicación, festivos, bajas…)
                var dailyHours = await _workCalendarService.CalculateDailyWorkHoursWithDedicationAndLeaves(personId, month.Year, month.Month);
                var requiredHoursBase = dailyHours.Values.Sum();

                // HORAS declaradas
                var declaredDict = await _workCalendarService.GetDeclaredHoursPerMonthForPerson(personId, month, month);
                declaredDict.TryGetValue(month, out decimal declared);

                // Umbral final (aplica "cap" si el flag está ON)
                var requiredThreshold = await GetRequiredThresholdAsync(personId, month.Year, month.Month, requiredHoursBase);

                // Añadir a la lista solo si hay umbral > 0 y está incompleto
                if (requiredThreshold > 0m && declared < requiredThreshold)
                {
                    pending.Add((month, declared, requiredThreshold)); // guardamos el threshold como “Required”
                }
            }

            return pending;
        }


        // Comprueba si la persona tenía al menos un WP activo ese mes Y effort > 0 en ese mes
        private async Task<bool> HasActiveAssignmentWithEffortAsync(int personId, int year, int month)
        {
            var first = new DateTime(year, month, 1);
            var last = first.AddMonths(1).AddDays(-1);

            return await _context.Persefforts.AnyAsync(e =>
                e.Value > 0 &&
                e.Month >= first && e.Month <= last &&
                e.WpxPersonNavigation.Person == personId &&
                // Asegura que el WP de esa asignación estaba activo ese mes:
                e.WpxPersonNavigation.WpNavigation.StartDate <= last &&
                e.WpxPersonNavigation.WpNavigation.EndDate >= first
            );
        }

        private async Task SendEmailWithGuideAsync(string to, string subject, string htmlBody, string? copyTo = null)
        {
            byte[]? pdfBytes = null;

            if (System.IO.File.Exists(GuidePdfPath))
            {
                try { pdfBytes = await System.IO.File.ReadAllBytesAsync(GuidePdfPath); }
                catch (Exception ex) { _logger.LogWarning(ex, "No se pudo leer el PDF de guía en {Path}", GuidePdfPath); }
            }
            else
            {
                _logger.LogWarning("El PDF de guía no existe en {Path}. Se enviará sin adjunto.", GuidePdfPath);
            }

            if (_emailSender is IEmailSenderWithAttachments senderWithAttach)
            {
                var attachment = pdfBytes != null
                    ? new[] { new EmailAttachment("BSC TRS 3.0 - Guide.pdf", pdfBytes, GuidePdfContentType) }
                    : Array.Empty<EmailAttachment>();

                await senderWithAttach.SendEmailAsync(
                    to: to,
                    subject: subject,
                    htmlBody: htmlBody,
                    attachments: attachment,
                    copyTo: copyTo,
                    replyTo: _options.ReplyTo,                 // 👈 Reply-To desde opciones
                    fromDisplayName: _options.FromDisplayName  // 👈 Nombre visible
                );
            }
            else
            {
                var bodyWithLink = htmlBody.Replace(
                    "A detailed user guide is attached to this email",
                    "A detailed user guide is available <a href=\"/docs/BSC_TRS_Guide_v1.pdf\">here</a>");

                await _emailSender.SendEmailAsync(
                    email: to,
                    subject: subject,
                    message: bodyWithLink,
                    replyTo: _options.ReplyTo,                 // 👈 Reply-To
                    fromDisplayName: _options.FromDisplayName  // 👈 Nombre visible
                );
            }
        }

        private async Task<decimal> GetAssignedFractionAsync(int personId, int year, int month)
        {
            var first = new DateTime(year, month, 1);
            var last = first.AddMonths(1).AddDays(-1);

            var sum = await _context.Persefforts
                .Where(e =>
                    e.Value > 0 &&
                    e.Month >= first && e.Month <= last &&
                    e.WpxPersonNavigation.Person == personId &&
                    e.WpxPersonNavigation.WpNavigation.StartDate <= last &&
                    e.WpxPersonNavigation.WpNavigation.EndDate >= first)
                .SumAsync(e => (decimal?)e.Value) ?? 0m;

            if (sum < 0m) sum = 0m;
            if (sum > 1m) sum = 1m;
            return sum;
        }

        private async Task<decimal> GetRequiredThresholdAsync(int personId, int year, int month, decimal requiredHoursBase)
        {
            if (!_options.UseAssignmentCap)
                return requiredHoursBase;

            var assignedFraction = await GetAssignedFractionAsync(personId, year, month);

            // Si no hay asignación (>0) ese mes, no avisamos
            if (assignedFraction <= 0m)
                return 0m;

            var threshold = requiredHoursBase * assignedFraction;

            // Redondeo suave para evitar falsos positivos por decimales
            return Math.Round(threshold, 1, MidpointRounding.AwayFromZero);
        }

        private async Task<bool> IsContractActiveAsync(int personId, DateTime onDate)
        {
            return await _context.Dedications.AnyAsync(d =>
                d.PersId == personId &&
                d.Start <= onDate &&
                d.End >= onDate
            );
        }

    }
}



----- FILE: C:\Users\premo\source\repos\trs3.0nuevo\TRS2.0\Services\RoleService.cs -----
using Microsoft.AspNetCore.Identity;
using System.Threading.Tasks;
using TRS2._0.Models.DataModels.TRS2._0.Models.DataModels;

namespace TRS2._0.Services
{
    public class RoleService
    {
        private readonly RoleManager<IdentityRole> _roleManager;
        private readonly UserManager<ApplicationUser> _userManager;

        public RoleService(RoleManager<IdentityRole> roleManager, UserManager<ApplicationUser> userManager)
        {
            _roleManager = roleManager;
            _userManager = userManager;
        }

        public async Task<IdentityResult> AssignRoleToUser(string userId, string roleName)
        {
            var user = await _userManager.FindByIdAsync(userId);
            if (user == null)
                return IdentityResult.Failed(new IdentityError { Description = "User not found." });

            if (!await _roleManager.RoleExistsAsync(roleName))
                return IdentityResult.Failed(new IdentityError { Description = $"Role '{roleName}' does not exist." });

            var result = await _userManager.AddToRoleAsync(user, roleName);
            return result;
        }

    }
}



----- FILE: C:\Users\premo\source\repos\trs3.0nuevo\TRS2.0\Services\WorkCalendarService.cs -----
using System;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using TRS2._0.Models.DataModels;
using Newtonsoft.Json.Linq;
using TRS2._0.Models.ViewModels;
using static TRS2._0.Models.ViewModels.PersonnelEffortPlanViewModel;
using System.Diagnostics;
using Serilog;
using System.Text;
namespace TRS2._0.Services;

public class WorkCalendarService
{
        private readonly TRSDBContext _context;
        private readonly ILogger<WorkCalendarService> _logger;

    public WorkCalendarService(TRSDBContext context, ILogger<WorkCalendarService> logger)
    {
            _context = context;
            _logger = logger;
    }

        public async Task<int> CalculateWorkingDays(int year, int month)
        {
            // Obtiene el número de días en el mes
            int daysInMonth = DateTime.DaysInMonth(year, month);
            int workingDays = 0;

            for (int day = 1; day <= daysInMonth; day++)
            {
                DateTime currentDate = new DateTime(year, month, day);

                // Comprueba si el día actual no es ni sábado ni domingo
                if (currentDate.DayOfWeek != DayOfWeek.Saturday && currentDate.DayOfWeek != DayOfWeek.Sunday)
                {
                    // Comprueba si el día actual no es un día festivo
                    bool isHoliday = await _context.NationalHolidays
                        .AnyAsync(h => h.Date == currentDate);

                    if (!isHoliday)
                    {
                        workingDays++;
                    }
                }
            }

            return workingDays;
        }

    public async Task<decimal> CalculateDailyPM(int personId, DateTime date)
    {
        // Comprobar si hay una ausencia registrada en la tabla 'Leave'
        bool isOnLeave = await _context.Leaves.AnyAsync(l => l.PersonId == personId && l.Day == date);
        if (isOnLeave)
        {
            return 0; // PM es 0 si la persona está ausente
        }

        // Obtener el valor de PM del día
        var dailyPmValue = await _context.DailyPMValues
            .Where(d => d.Year == date.Year && d.Month == date.Month)
            .Select(d => d.PmPerDay)
            .FirstOrDefaultAsync();

        // Obtener la dedicación aplicable para la fecha
        var applicableDedication = await _context.Dedications
            .Where(d => d.PersId == personId && d.Start <= date && d.End >= date)
            .OrderByDescending(d => d.Type) // Priorizar por el 'Type' más alto
            .Select(d => d.Reduc)
            .FirstOrDefaultAsync();

        return dailyPmValue * (1 - applicableDedication); // Aplicar reducción
    }

    public async Task<decimal> CalculateMonthlyPM(int personId, int year, int month)
    {
        // Obtener todos los contratos (dedicaciones) para el mes y año especificados
        var dedications = await _context.Dedications
            .Where(d => d.PersId == personId &&
                        d.Start <= new DateTime(year, month, DateTime.DaysInMonth(year, month)) &&
                        d.End >= new DateTime(year, month, 1))
            .OrderBy(d => d.Start)
            .ToListAsync();

        // Si no hay dedicaciones que cubran el mes, retornar PM como 0
        if (!dedications.Any())
        {
            return 0;
        }

        // Obtener los días festivos para el mes y año especificados
        var holidays = await _context.NationalHolidays
            .Where(h => h.Date.Year == year && h.Date.Month == month)
            .Select(h => h.Date)
            .ToListAsync();

        // Obtener los registros de bajas (Leave) para el mes y año especificados
        var leaveRecords = await _context.Leaves
            .Where(l => l.PersonId == personId && l.Day.Year == year && l.Day.Month == month)
            .ToDictionaryAsync(l => l.Day, l => new { l.LeaveReduction, l.Type });

        // Valor de PM por día obtenido de la tabla DailyPMValues
        var dailyPmValue = await _context.DailyPMValues
            .Where(d => d.Year == year && d.Month == month)
            .Select(d => d.PmPerDay)
            .FirstOrDefaultAsync();

        decimal totalPm = 0;

        // Procesar cada día del mes
        for (DateTime currentDate = new DateTime(year, month, 1); currentDate <= new DateTime(year, month, DateTime.DaysInMonth(year, month)); currentDate = currentDate.AddDays(1))
        {
            // Omitir sábados, domingos, días festivos
            if (currentDate.DayOfWeek == DayOfWeek.Saturday ||
                currentDate.DayOfWeek == DayOfWeek.Sunday ||
                holidays.Contains(currentDate))
            {
                continue;
            }

            // Obtener la reducción de baja si existe
            var leaveData = leaveRecords.TryGetValue(currentDate, out var leave) ? leave : null;
            var leaveReduction = leaveData?.LeaveReduction ?? 0;
            var leaveType = leaveData?.Type ?? 0;

            // Obtener la reducción de dedicación más actual para la fecha
            var applicableDedication = dedications
                .Where(d => currentDate >= d.Start && currentDate <= d.End)
                .OrderByDescending(d => d.Type) // Dar prioridad a la dedicación con el 'Type' más alto
                .Select(d => d.Reduc)
                .FirstOrDefault();

            // Manejar el caso específico de baja de paternidad (Type 12)
            if (leaveType == 12)
            {
                // Aplicar la reducción de baja al PM ajustado por la dedicación
                var adjustedPmForDedication = dailyPmValue * (1 - applicableDedication);
                totalPm += adjustedPmForDedication * (1 - leaveReduction); // Baja afecta al PM ya ajustado
            }
            else
            {
                // Sumar el PM ajustado por la suma de reducciones estándar
                var totalReduction = Math.Min(1, applicableDedication + leaveReduction);
                if (totalReduction < 1)
                {
                    totalPm += dailyPmValue * (1 - totalReduction);
                }
            }

            // Asegurarse de que totalPm no exceda 1
            totalPm = Math.Min(totalPm, 1);
        }

        // Redondear el PM total a 2 decimales y devolverlo
        return Math.Round(totalPm, 2);
    }




    public async Task<decimal> CalculateMonthlyEffortForPerson(int personId, int year, int month)
    {
        // Obtener todos los esfuerzos asociados a la persona que están dentro del rango de fechas especificado
        var efforts = await _context.Persefforts
            .Include(pe => pe.WpxPersonNavigation)
            .Where(pe => pe.WpxPersonNavigation.Person == personId &&
                         pe.Month.Year == year &&
                         pe.Month.Month == month)
            .ToListAsync();

        // Sumar los valores de esfuerzo para el mes dado
        decimal totalEffort = efforts.Sum(e => e.Value);

        return Math.Round(totalEffort, 2);
    }

    public async Task<decimal> CalculateMonthlyEffortForPersonWithoutCurrentWP(int personId,int wpId, int year, int month)
    {
        // Obtener todos los esfuerzos asociados a la persona que están dentro del rango de fechas especificado
        var efforts = await _context.Persefforts
            .Include(pe => pe.WpxPersonNavigation)
            .Where(pe => pe.WpxPersonNavigation.Person == personId &&
                         pe.Month.Year == year &&
                         pe.Month.Month == month)
            .ToListAsync();

        var effortforthiswp = efforts.Where(e => e.WpxPersonNavigation.Wp == wpId).ToList();

        var sumefforts = effortforthiswp.Sum(e => e.Value);

        // Sumar los valores de esfuerzo para el mes dado
        decimal totalEffort = efforts.Sum(e => e.Value);

        totalEffort = totalEffort - sumefforts;

        return Math.Round(totalEffort, 2);
    }

    public async Task<Dictionary<DateTime, decimal>> CalculateMonthlyEffortForPersonInProject(int personId, DateTime startDate, DateTime endDate, int projectId)
    {
        // Asegurarse de que la fecha de fin sea al menos el último momento del mes indicado
        endDate = new DateTime(endDate.Year, endDate.Month, DateTime.DaysInMonth(endDate.Year, endDate.Month));

        // Obtener todos los esfuerzos asociados a la persona dentro del rango de fechas y proyecto especificado
        var efforts = await _context.Persefforts
            .Include(pe => pe.WpxPersonNavigation)
            .Where(pe => pe.WpxPersonNavigation.Person == personId &&
                         pe.WpxPersonNavigation.WpNavigation.ProjId == projectId &&
                         pe.Month >= startDate && pe.Month <= endDate)
            .ToListAsync();

        // Agrupar los esfuerzos por mes y sumarlos
        var monthlyEfforts = efforts
            .GroupBy(pe => new DateTime(pe.Month.Year, pe.Month.Month, 1))
            .Select(g => new { Month = g.Key, TotalEffort = g.Sum(e => e.Value) })
            .ToDictionary(g => g.Month, g => Math.Round(g.TotalEffort, 2));

        return monthlyEfforts;
    }



    public async Task<Dictionary<DateTime, decimal>> GetDeclaredHoursPerMonthForPerson(int personId, DateTime startDate, DateTime endDate)
    {
        // Asegúrate de que endDate es el último momento del mes para incluir todos los días del mes
        endDate = new DateTime(endDate.Year, endDate.Month, DateTime.DaysInMonth(endDate.Year, endDate.Month));

        var hoursPerMonth = await _context.Timesheets
            .Where(ts => ts.WpxPersonNavigation.Person == personId &&
                         ts.Day >= startDate &&
                         ts.Day <= endDate)
            .GroupBy(ts => new
            {
                Year = ts.Day.Year,
                Month = ts.Day.Month
            })
            .Select(g => new
            {
                Month = new DateTime(g.Key.Year, g.Key.Month, 1), // Usa el primer día del mes como clave
                TotalHours = g.Sum(ts => ts.Hours) // Suma las horas declaradas
            })
            .ToDictionaryAsync(g => g.Month, g => g.TotalHours);

        return hoursPerMonth;
    }

    public async Task<Dictionary<DateTime, decimal>> GetDeclaredHoursPerMonthForPersonInProyect(int personId, DateTime startDate, DateTime endDate, int projectId)
    {
        // Asegúrate de que endDate es el último momento del mes para incluir todos los días del mes
        endDate = new DateTime(endDate.Year, endDate.Month, DateTime.DaysInMonth(endDate.Year, endDate.Month));

        var hoursPerMonth = await _context.Timesheets
            .Where(ts => ts.WpxPersonNavigation.Person == personId &&
                                    ts.WpxPersonNavigation.WpNavigation.ProjId == projectId &&
                                                            ts.Day >= startDate &&
                                                                                    ts.Day <= endDate)
            .GroupBy(ts => new
            {
                Year = ts.Day.Year,
                Month = ts.Day.Month
            })
            .Select(g => new
            {
                Month = new DateTime(g.Key.Year, g.Key.Month, 1), // Usa el primer día del mes como clave
                TotalHours = g.Sum(ts => ts.Hours) // Suma las horas declaradas
            })
            .ToDictionaryAsync(g => g.Month, g => g.TotalHours);

        return hoursPerMonth;
    }


    // -----------------------------------------------------------------------------------
    // [CHANGE] GetWorkedDaysPerMonthForPersonInProject
    // Actualizado el 30/04/2025
    // - Ahora el cálculo de días trabajados se basa en:
    //    - Horas reales declaradas en Timesheets del proyecto.
    //    - Afiliación activa en el mes con mayor número de horas por día.
    //    - División y redondeo con Math.Round(..., MidpointRounding.AwayFromZero).
    // - Si no hay afiliación válida, marca como "SIN AFILIACIÓN".
    // Esta lógica replica exactamente el método de ExportTimesheetToPdf2 en TimesheetController.
    // -----------------------------------------------------------------------------------

    public async Task<Dictionary<DateTime, decimal>> GetWorkedDaysPerMonthForPersonInProject(int personId, DateTime startDate, DateTime endDate, int projectId)
    {
        var declaredHoursPerMonth = await GetDeclaredHoursPerMonthForPersonInProyect(personId, startDate, endDate, projectId);

        var affiliations = await _context.AffxPersons
            .Where(a => a.PersonId == personId &&
                        a.Start <= endDate && a.End >= startDate)
            .ToListAsync();

        var affHoursList = await _context.AffHours.ToListAsync();

        Dictionary<DateTime, decimal> workedDaysPerMonth = new Dictionary<DateTime, decimal>();

        foreach (var entry in declaredHoursPerMonth)
        {
            DateTime month = entry.Key;
            decimal totalDeclaredHours = entry.Value;

            var monthAffiliations = affiliations
                .Where(a => a.Start <= month.AddMonths(1).AddDays(-1) && a.End >= month)
                .ToList();

            if (!monthAffiliations.Any())
            {
                workedDaysPerMonth[month] = -1; // SIN AFILIACIÓN
                continue;
            }

            // Aquí: obtener correctamente la hora diaria vigente en este mes
            List<decimal> activeAffiliationHours = new List<decimal>();

            foreach (var affiliation in monthAffiliations)
            {
                var validAffHours = affHoursList
                    .Where(ah => ah.AffId == affiliation.AffId &&
                                 ah.StartDate <= month.AddMonths(1).AddDays(-1) &&
                                 ah.EndDate >= month)
                    .ToList();

                foreach (var v in validAffHours)
                {
                    if (v.Hours > 0)
                    {
                        activeAffiliationHours.Add(v.Hours);
                    }
                }
            }

            if (!activeAffiliationHours.Any())
            {
                workedDaysPerMonth[month] = -1; // No hay afiliaciones válidas para este mes
                continue;
            }

            // Usar la afiliación de MENOS horas (como en Timesheet real)
            decimal selectedAffiliationHours = activeAffiliationHours.Min();

            decimal workedDays = Math.Round(totalDeclaredHours / selectedAffiliationHours, 1, MidpointRounding.AwayFromZero);
            workedDaysPerMonth[month] = workedDays;
        }

        return workedDaysPerMonth;
    }





    public async Task<Dictionary<DateTime, decimal>> CalculateTotalHoursForPerson(int personId, DateTime startDate, DateTime endDate, int projectId, Dictionary<DateTime, int> workingDaysPerMonth)
    {
        var totalExecutionStopwatch = Stopwatch.StartNew();

        var totalHoursPerMonth = new Dictionary<DateTime, decimal>();

        var affiliationsStopwatch = Stopwatch.StartNew();
        var affiliations = await _context.AffxPersons
            .Where(a => a.PersonId == personId && !(a.End < startDate || a.Start > endDate))
            .Include(a => a.Affiliation)
            .ToListAsync();
        affiliationsStopwatch.Stop();
        Console.WriteLine($"Affiliations fetch took: {affiliationsStopwatch.ElapsedMilliseconds} ms");

        var affHoursStopwatch = Stopwatch.StartNew();
        var affHoursList = await _context.AffHours
            .Where(ah => affiliations.Select(a => a.AffId).Contains(ah.AffId) &&
                         ah.EndDate >= startDate &&
                         ah.StartDate <= endDate)
            .ToListAsync();
        affHoursStopwatch.Stop();
        Console.WriteLine($"AffHours fetch took: {affHoursStopwatch.ElapsedMilliseconds} ms");

        startDate = new DateTime(startDate.Year, startDate.Month, 1);
        endDate = new DateTime(endDate.Year, endDate.Month, DateTime.DaysInMonth(endDate.Year, endDate.Month));

        var monthlyCalculationStopwatch = new Stopwatch();

        while (startDate <= endDate)
        {
            decimal hoursForMonth = 0;
            if (workingDaysPerMonth.TryGetValue(new DateTime(startDate.Year, startDate.Month, 1), out int workingDays))
            {
                
                // Aquí utilizas workingDays obtenidos de DailyPmValues
                foreach (var affiliation in affiliations)
                {
                    var affHours = affHoursList.FirstOrDefault(ah => ah.AffId == affiliation.AffId && ah.StartDate <= startDate && ah.EndDate >= startDate)?.Hours ?? 0;
                    hoursForMonth += affHours * workingDays;
                }

                if (affiliations.Any())
                {
                    hoursForMonth /= affiliations.Count;
                }

                totalHoursPerMonth.Add(new DateTime(startDate.Year, startDate.Month, 1), hoursForMonth);
            }

            startDate = startDate.AddMonths(1);
        }

        totalExecutionStopwatch.Stop();
        Console.WriteLine($"Total execution time of CalculateTotalHoursForPerson: {totalExecutionStopwatch.ElapsedMilliseconds} ms");

        return totalHoursPerMonth;
    }

    public async Task<Dictionary<DateTime, decimal>> CalculateTotalHoursForPersonV2(
    int personId,
    DateTime startDate,
    DateTime endDate)
    {
        var totalHoursPerMonth = new Dictionary<DateTime, decimal>();

        startDate = new DateTime(startDate.Year, startDate.Month, 1);
        endDate = new DateTime(endDate.Year, endDate.Month, DateTime.DaysInMonth(endDate.Year, endDate.Month));

        while (startDate <= endDate)
        {
            var monthKey = new DateTime(startDate.Year, startDate.Month, 1);
            decimal hours = await CalculateMaxHoursForPersonInMonth(personId, startDate.Year, startDate.Month);
            totalHoursPerMonth[monthKey] = hours;

            startDate = startDate.AddMonths(1);
        }

        return totalHoursPerMonth;
    }

    public async Task<bool> IsOutOfContract(int personId, int year, int month)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        // Comprobamos si existe algún registro en la tabla 'Dedication' que coincida con el mes y año dado,
        // donde el inicio del contrato sea anterior o igual al final del mes y el fin del contrato sea posterior o igual al inicio del mes.
        var isOutOfContract = !await _context.Dedications.AnyAsync(d => d.PersId == personId &&
                                                                    d.Start <= endDate &&
                                                                    d.End >= startDate);

        return isOutOfContract;
    }

    public async Task<bool> IsOverloaded(decimal monthlyEffort, decimal monthlyPm)
    {
        return monthlyEffort > monthlyPm;
    }

    public async Task<List<Leave>> GetLeavesForPerson(int personId, int year, int month)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        // Realiza la consulta a la base de datos para obtener las ausencias que ocurren dentro del mes dado.
        var leaves = await _context.Leaves
                            .Where(l => l.PersonId == personId
                                        && l.Day >= startDate
                                        && l.Day <= endDate
                                        )
                            .ToListAsync();

        return leaves;
    }

    public async Task<List<MonthStatus>> CalculateMonthlyStatusesForPerson(int personId, List<DateTime> uniqueMonths, Dictionary<string, decimal> totalEffortsPerMonth, Dictionary<string, decimal> pmValuesPerMonth)
    {
        var monthStatuses = new List<MonthStatus>();

        foreach (var month in uniqueMonths)
        {
            int status = 0;
            List<int> additionalStatuses = new List<int>();
            string gradient = "";

            bool isOutOfContract = await IsOutOfContract(personId, month.Year, month.Month);
            if (isOutOfContract)
            {
                status = 1; // OutOfContract
            }
            else
            {
                string monthKey = $"{month.Year}-{month.Month:D2}";
                if (totalEffortsPerMonth.ContainsKey(monthKey) && pmValuesPerMonth.ContainsKey(monthKey))
                {
                    bool isOverloaded = totalEffortsPerMonth[monthKey] > pmValuesPerMonth[monthKey];
                    if (isOverloaded)
                    {
                        status = 2; // Overloaded
                    }
                }

                if (status == 0)
                {
                    var leaves = await GetLeavesForPerson(personId, month.Year, month.Month);
                    foreach (var leave in leaves)
                    {
                        switch (leave.Type)
                        {
                            case 1: // Leave
                                additionalStatuses.Add(3);
                                gradient += "darkorange, ";
                                break;
                            case 2: // Personal Holiday
                                additionalStatuses.Add(4);
                                gradient += "lightblue, ";
                                break;
                            case 3: // No Contract Period
                                additionalStatuses.Add(5);
                                gradient += "purple, ";
                                break;
                        }
                    }
                    if (gradient.Length > 0)
                    {
                        gradient = $"linear-gradient({gradient.TrimEnd(',', ' ')})";
                        status = 3; // Setting status to 3 for leaves as default if not already set.
                    }
                }
            }

            monthStatuses.Add(new MonthStatus
            {
                Month = month,
                Status = status,
                AdditionalStatuses = additionalStatuses,
                Gradient = gradient
            });
        }

        return monthStatuses;
    }

    public async Task<List<MonthStatus>> CalculateMonthlyStatusesForPersonWithLists(
    int personId,
    List<DateTime> uniqueMonths,
    Dictionary<string, decimal> totalEffortsPerMonth,
    Dictionary<string, decimal> pmValuesPerMonth,
    List<ProjectMonthLock> projectMonthLocks)
    {
        var monthStatuses = new List<MonthStatus>();
        var outOfContractForMonths = await IsOutOfContractForMonths(personId, uniqueMonths);
        var leavesForMonths = await GetLeavesForMonths(personId, uniqueMonths);
        var travelDetailsForMonths = await GetTravelDatesForMonths(personId, uniqueMonths);

        foreach (var month in uniqueMonths)
        {
            int status = 0;
            var additionalStatuses = new List<int>();
            var gradientParts = new List<string>();
            var monthKey = $"{month.Year}-{month.Month:D2}";
            var travelDetails = travelDetailsForMonths.GetValueOrDefault(month, new List<TravelDetails>());
            bool isLocked = projectMonthLocks.Any(l => l.Year == month.Year && l.Month == month.Month && l.IsLocked);

            // Determine if out of contract
            if (outOfContractForMonths.TryGetValue(month, out bool isOutOfContract) && isOutOfContract)
            {
                status = 1; // OutOfContract
            }
            else if (totalEffortsPerMonth.TryGetValue(monthKey, out decimal totalEffort) &&
                     pmValuesPerMonth.TryGetValue(monthKey, out decimal pmValue) &&
                     totalEffort > pmValue)
            {
                status = 2; // Overloaded
            }

            // Process leaves if not out of contract or overloaded
            if (status == 0 && leavesForMonths.TryGetValue(month, out var leaves))
            {
                foreach (var leave in leaves)
                {
                    switch (leave.Type)
                    {
                        case 1: // Leave
                            additionalStatuses.Add(3);
                            gradientParts.Add("darkorange");
                            break;
                        case 2: // Personal Holiday
                            additionalStatuses.Add(4);
                            gradientParts.Add("lightblue");
                            break;
                        case 3: // No Contract Period
                            additionalStatuses.Add(5);
                            gradientParts.Add("purple");
                            break;
                    }
                }
            }
            
            // Check for travels in the current month
            if (status == 0 && travelDetails.Any())
            {
                status = 4; // Estado para indicar que hay viajes
                
            }
            if (gradientParts.Any())
            {
                var gradient = $"linear-gradient(to right, {string.Join(", ", gradientParts)})";
                // Set status to 3 for leaves if there are any leaves
                status = 3;
            }

            var uniqueProjIds = travelDetails.Select(td => td.ProjId).Distinct().ToList();

            monthStatuses.Add(new MonthStatus
            {
                Month = month,
                Status = status,
                IsLocked = isLocked,
                AdditionalStatuses = additionalStatuses,
                Gradient = gradientParts.Any() ? $"linear-gradient(to right, {string.Join(", ", gradientParts)})" : "",
                TravelDetails = travelDetails,
                UniqueProjIds = uniqueProjIds // Lista de projId únicos para los viajes de ese mes
            });
        }

        return monthStatuses;
    }


    public async Task<Dictionary<DateTime, bool>> IsOutOfContractForMonths(int personId, List<DateTime> months)
    {
        var startDates = months.Select(m => new DateTime(m.Year, m.Month, 1)).ToList();
        var endDates = months.Select(m => new DateTime(m.Year, m.Month, DateTime.DaysInMonth(m.Year, m.Month))).ToList();

        Console.WriteLine($"Min Start Date: {startDates.Min()}");
        Console.WriteLine($"Max End Date: {endDates.Max()}");

        if (!startDates.Any() || !endDates.Any())
        {
            return new Dictionary<DateTime, bool>(); // Retorna un diccionario vacío si no hay fechas de inicio o fin.
        }

        var minStartDate = startDates.Min();
        var maxEndDate = endDates.Max();


        var contracts = await _context.Dedications
                        .Where(d => d.PersId == personId && d.End >= minStartDate && d.Start <= maxEndDate)
                        .ToListAsync();


        var outOfContract = new Dictionary<DateTime, bool>();
        foreach (var month in months)
        {
            var startDate = new DateTime(month.Year, month.Month, 1);
            var endDate = startDate.AddMonths(1).AddDays(-1);
            // Verificar si existe algún contrato que cubra el mes actual
            outOfContract[month] = !contracts.Any(d => d.Start <= endDate && d.End >= startDate);
        }

        return outOfContract;
    }

    public async Task<Dictionary<DateTime, List<Leave>>> GetLeavesForMonths(int personId, List<DateTime> months)
    {
        var startDate = months.Min(m => new DateTime(m.Year, m.Month, 1));
        var endDate = months.Max(m => new DateTime(m.Year, m.Month, DateTime.DaysInMonth(m.Year, m.Month)));

        var leaves = await _context.Leaves
            .Where(l => l.PersonId == personId && l.Day >= startDate && l.Day <= endDate)
            .ToListAsync();

        var leavesByMonth = new Dictionary<DateTime, List<Leave>>();
        foreach (var month in months)
        {
            leavesByMonth[month] = leaves.Where(l => l.Day.Year == month.Year && l.Day.Month == month.Month).ToList();
        }

        return leavesByMonth;
    }

    

    public async Task<Dictionary<DateTime, List<TravelDetails>>> GetTravelDatesForMonths(int personId, List<DateTime> uniqueMonths)
    {
        var travelDatesForMonths = new Dictionary<DateTime, List<TravelDetails>>();

        // Paso 1: Recuperar todos los viajes para la persona sin filtrar por 'uniqueMonths' directamente en la consulta.
        var allTravels = await _context.liqdayxproject
            .Where(ldp => ldp.PersId == personId)
            .Select(ldp => new TravelDetails { Day = ldp.Day, ProjId = ldp.ProjId })
            .ToListAsync();

        // Paso 2: Filtrar los viajes en memoria para asociarlos con los meses correspondientes.
        foreach (var month in uniqueMonths)
        {
            var firstDayOfMonth = new DateTime(month.Year, month.Month, 1);
            var lastDayOfMonth = firstDayOfMonth.AddMonths(1).AddDays(-1);

            var travelsInMonth = allTravels
                .Where(td => td.Day >= firstDayOfMonth && td.Day <= lastDayOfMonth)
                .ToList();

            travelDatesForMonths.Add(month, travelsInMonth);
        }

        return travelDatesForMonths;
    }

    public async Task<List<DateTime>> GetDaysForPerson(int personId, int year, int month)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        var days = await _context.Timesheets
            .Where(ts => ts.WpxPersonNavigation.Person == personId && ts.Day >= startDate && ts.Day <= endDate)
            .Select(ts => ts.Day)
            .Distinct()
            .ToListAsync();

        return days;
    }

    public async Task<List<string>> GetFormattedDaysOfMonthAsync(int year, int month)
    {
        // Lista para almacenar los días formateados
        List<string> formattedDays = new List<string>();

        // Calcula el número de días en el mes especificado
        int daysInMonth = DateTime.DaysInMonth(year, month);

        // Recorre todos los días del mes
        for (int day = 1; day <= daysInMonth; day++)
        {
            // Simula una operación asíncrona, por ejemplo, esperando una tarea completada
            await Task.CompletedTask;

            // Crea una fecha con el año, mes y día actual del bucle
            DateTime date = new DateTime(year, month, day);

            // Formatea el día y el nombre del día en inglés
            string formattedDay = $"{date:dd} {date:dddd}";

            // Agrega el día formateado a la lista
            formattedDays.Add(formattedDay);
        }

        return formattedDays;
    }

    public async Task<List<TravelDetails>> GetTravelsForThisMonth(int personId, int year, int month)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        var travels = await _context.liqdayxproject
            .Where(ldp => ldp.PersId == personId && ldp.Day >= startDate && ldp.Day <= endDate)
            .GroupBy(ldp => new { ldp.LiqId, ldp.ProjId })
            .Select(g => new
            {
                LiqId = g.Key.LiqId,
                ProjId = g.Key.ProjId,
                Dedication = g.Average(ldp => ldp.Dedication), 
                StartDate = g.Min(ldp => ldp.Day),
                EndDate = g.Max(ldp => ldp.Day),
                Project = g.Select(ldp => ldp.Project).FirstOrDefault() // Asume que todos los registros tienen el mismo proyecto
            })
            .ToListAsync();

        var travelDetailsList = travels.Select(t => new TravelDetails
        {
            LiqId = t.LiqId,
            ProjId = t.ProjId,
            Dedication = t.Dedication,
            StartDate = t.StartDate,
            EndDate = t.EndDate,
            ProjectAcronimo = t.Project.Acronim,
            ProjectSAPCode = t.Project.SapCode
        }).ToList();

        return travelDetailsList;
    }



    public async Task<Dictionary<DateTime, decimal>> CalculateDailyWorkHours(int personId, int year, int month)
    {
        var dailyWorkHours = new Dictionary<DateTime, decimal>();
        DateTime startDate = new DateTime(year, month, 1);
        int daysInMonth = DateTime.DaysInMonth(year, month);
        decimal monthlyDedication = await CalculateMonthlyPM(personId, year, month); 

        // Obtener todas las afiliaciones para la persona en el mes dado
        var affiliations = await _context.AffxPersons
                            .Where(ap => ap.PersonId == personId && ap.Start <= startDate.AddMonths(1).AddDays(-1) && ap.End >= startDate)
                            .Select(ap => ap.AffId)
                            .Distinct()
                            .ToListAsync();

        // Obtener las horas de trabajo de todas las afiliaciones aplicables
        var affHoursList = await _context.AffHours
                            .Where(ah => affiliations.Contains(ah.AffId) && ah.StartDate <= startDate.AddMonths(1).AddDays(-1) && ah.EndDate >= startDate)
                            .ToListAsync();

        for (int day = 1; day <= daysInMonth; day++)
        {
            DateTime currentDate = new DateTime(year, month, day);

            // Ignora sábados, domingos y festivos
            if (currentDate.DayOfWeek == DayOfWeek.Saturday || currentDate.DayOfWeek == DayOfWeek.Sunday || await IsHoliday(currentDate))
            {
                continue;
            }

            // Encuentra las horas de afiliación aplicables para el día actual
            var currentHours = affHoursList.FirstOrDefault(ah => currentDate >= ah.StartDate && currentDate <= ah.EndDate)?.Hours ?? 0;

            // Ajusta las horas diarias por la dedicación mensual
            decimal adjustedDailyHours = currentHours * monthlyDedication;

            dailyWorkHours.Add(currentDate, adjustedDailyHours);
        }

        return dailyWorkHours;
    }

    public async Task<Dictionary<DateTime, decimal>> CalculateDailyWorkHoursWithDedication(int personId, int year, int month)
    {
        var dailyWorkHours = new Dictionary<DateTime, decimal>();
        DateTime startDate = new DateTime(year, month, 1);
        int daysInMonth = DateTime.DaysInMonth(year, month);

        // Obtener todas las afiliaciones y dedicaciones para la persona en el mes dado
        var affiliations = await _context.AffxPersons
                            .Include(ap => ap.Affiliation) // Asegúrate de incluir las entidades relacionadas necesarias
                            .Where(ap => ap.PersonId == personId && ap.Start <= startDate.AddMonths(1).AddDays(-1) && ap.End >= startDate)
                            .ToListAsync();

        // Obtener las dedicaciones del mes para la persona
        var dedications = await _context.Dedications
                            .Where(d => d.PersId == personId && d.Start <= startDate.AddMonths(1).AddDays(-1) && d.End >= startDate)
                            .ToListAsync();

        for (int day = 1; day <= daysInMonth; day++)
        {
            DateTime currentDate = new DateTime(year, month, day);

            // Ignora sábados, domingos y festivos
            if (currentDate.DayOfWeek == DayOfWeek.Saturday || currentDate.DayOfWeek == DayOfWeek.Sunday || await IsHoliday(currentDate))
            {
                continue;
            }

            // Encuentra las horas de afiliación y dedicación aplicables para el día actual
            var currentAffiliationHours = affiliations
                .Where(ap => currentDate >= ap.Start && currentDate <= ap.End)
                .SelectMany(ap => _context.AffHours.Where(ah => ah.AffId == ap.AffId && currentDate >= ah.StartDate && currentDate <= ah.EndDate))
                .FirstOrDefault()?.Hours ?? 0;

            // Seleccionar la dedicación con el valor Type más alto
            var currentDedication = dedications
                .Where(d => currentDate >= d.Start && currentDate <= d.End)
                .OrderByDescending(d => d.Type) // Ordenar por Type de mayor a menor
                .FirstOrDefault()?.Reduc;

            // Si no se encuentra dedicación específica o Reduc es 0.00, asume una jornada completa
            decimal dedicationFactor = currentDedication.HasValue ? currentDedication.Value : 0.00M;

            // Calcular las horas ajustadas para el día y redondearlas al entero o .5 más cercano
            decimal adjustedDailyHours = currentAffiliationHours * (1 - dedicationFactor);
            adjustedDailyHours = RoundToNearestHalfOrWhole(adjustedDailyHours);

            // Agregar al diccionario
            dailyWorkHours.Add(currentDate, adjustedDailyHours);
        }

        return dailyWorkHours;
    }

    public async Task<Dictionary<DateTime, decimal>> CalculateDailyWorkHoursWithDedicationNotRounded(int personId, int year, int month)
    {
        var dailyWorkHours = new Dictionary<DateTime, decimal>();
        DateTime startDate = new DateTime(year, month, 1);
        int daysInMonth = DateTime.DaysInMonth(year, month);

        // Obtener todas las afiliaciones y dedicaciones para la persona en el mes dado
        var affiliations = await _context.AffxPersons
                            .Include(ap => ap.Affiliation)
                            .Where(ap => ap.PersonId == personId && ap.Start <= startDate.AddMonths(1).AddDays(-1) && ap.End >= startDate)
                            .ToListAsync();

        var dedications = await _context.Dedications
                            .Where(d => d.PersId == personId && d.Start <= startDate.AddMonths(1).AddDays(-1) && d.End >= startDate)
                            .ToListAsync();

        for (int day = 1; day <= daysInMonth; day++)
        {
            DateTime currentDate = new DateTime(year, month, day);

            if (currentDate.DayOfWeek == DayOfWeek.Saturday || currentDate.DayOfWeek == DayOfWeek.Sunday || await IsHoliday(currentDate))
            {
                continue;
            }

            var currentAffiliationHours = affiliations
                .Where(ap => currentDate >= ap.Start && currentDate <= ap.End)
                .SelectMany(ap => _context.AffHours.Where(ah => ah.AffId == ap.AffId && currentDate >= ah.StartDate && currentDate <= ah.EndDate))
                .FirstOrDefault()?.Hours ?? 0;

            var currentDedication = dedications
                .Where(d => currentDate >= d.Start && currentDate <= d.End)
                .OrderByDescending(d => d.Type)
                .FirstOrDefault()?.Reduc;

            decimal dedicationFactor = currentDedication.HasValue ? currentDedication.Value : 0.00M;

            decimal adjustedDailyHours = currentAffiliationHours * (1 - dedicationFactor);
            adjustedDailyHours = Math.Round(adjustedDailyHours, 1, MidpointRounding.AwayFromZero); // precisión de 1 decimal

            dailyWorkHours.Add(currentDate, adjustedDailyHours);
        }

        return dailyWorkHours;
    }

    public async Task <List<DateTime>> GetHolidaysForMonth(int year, int month)
    {
        var holidays = await _context.NationalHolidays
            .Where(h => h.Date.Year == year && h.Date.Month == month)
            .Select(h => h.Date)
            .ToListAsync();

        return holidays;
    }

    // Función auxiliar para verificar si un día es festivo
    public async Task<bool> IsHoliday(DateTime date)
    {
        return await _context.NationalHolidays.AnyAsync(h => h.Date == date);
    }


    public async Task <bool> IsWeekend(DateTime date)
    {
        return date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday;
    }

    public async Task<decimal> CalculateAdjustedMonthlyPM(int personId, int year, int month, DateTime startDate, DateTime endDate)
    {
        // Asegurar que las fechas de inicio y fin están dentro del mes y año especificados
        startDate = new DateTime(year, month, 1) > startDate ? new DateTime(year, month, 1) : startDate;
        endDate = new DateTime(year, month, DateTime.DaysInMonth(year, month)) < endDate ? new DateTime(year, month, DateTime.DaysInMonth(year, month)) : endDate;

        var dedications = await _context.Dedications
            .Where(d => d.PersId == personId &&
                        d.Start <= endDate &&
                        d.End >= startDate)
            .OrderBy(d => d.Start)
            .ToListAsync();

        if (!dedications.Any())
        {
            return 0;
        }

        var holidays = await _context.NationalHolidays
            .Where(h => h.Date >= startDate && h.Date <= endDate)
            .Select(h => h.Date)
            .ToListAsync();

        var leaveDays = await _context.Leaves
            .Where(l => l.PersonId == personId && l.Day >= startDate && l.Day <= endDate)
            .Select(l => l.Day)
            .ToListAsync();

        decimal totalPm = 0;

        var dailyPmValue = await _context.DailyPMValues
            .Where(d => d.Year == year && d.Month == month)
            .Select(d => d.PmPerDay)
            .FirstOrDefaultAsync();

        for (DateTime currentDate = startDate; currentDate <= endDate; currentDate = currentDate.AddDays(1))
        {
            if (currentDate.DayOfWeek == DayOfWeek.Saturday ||
                currentDate.DayOfWeek == DayOfWeek.Sunday ||
                holidays.Contains(currentDate) ||
                leaveDays.Contains(currentDate))
            {
                continue;
            }

            var applicableDedication = dedications
                .Where(d => currentDate >= d.Start && currentDate <= d.End)
                .OrderByDescending(d => d.Type)
                .Select(d => d.Reduc)
                .FirstOrDefault();

            totalPm += dailyPmValue * (1 - applicableDedication);
        }

        return Math.Round(totalPm, 2);
    }

    public async Task<Dictionary<DateTime, int>> GetWorkingDaysFromDbForRange(DateTime startDate, DateTime endDate)
    {
        var workingDaysPerMonth = new Dictionary<DateTime, int>();

        // Obtén todos los valores dentro del rango de años.
        var dailyPmValuesInRange = await _context.DailyPMValues
            .Where(dpv => dpv.Year >= startDate.Year && dpv.Year <= endDate.Year)
            .ToListAsync();

        // Filtra los valores en memoria para incluir solo aquellos dentro del rango de meses.
        var filteredValues = dailyPmValuesInRange
            .Where(dpv =>
                new DateTime(dpv.Year, dpv.Month, 1) >= startDate &&
                new DateTime(dpv.Year, dpv.Month, 1) <= endDate)
            .ToList();

        foreach (var dpv in filteredValues)
        {
            DateTime firstDayOfMonth = new DateTime(dpv.Year, dpv.Month, 1);
            workingDaysPerMonth[firstDayOfMonth] = dpv.WorkableDays;
        }

        return workingDaysPerMonth;
    }

    public async Task<List<DateTime>> GenerateMonthList(DateTime startDate, DateTime endDate)
    {
        var months = new List<DateTime>();
        DateTime currentMonth = new DateTime(startDate.Year, startDate.Month, 1);

        while (currentMonth <= endDate)
        {
            months.Add(currentMonth);
            currentMonth = currentMonth.AddMonths(1);
        }

        return months;
    }
    public async Task<decimal> GetEffortForPersonInProject(int personId, int projectId, int year, int month)
    {
        // Obtener la fecha de inicio y fin del mes
        DateTime startDate = new DateTime(year, month, 1);
        DateTime endDate = startDate.AddMonths(1).AddDays(-1);

        // Obtener el esfuerzo mensual de la persona para el proyecto
        Dictionary<DateTime, decimal> monthlyEffort = await CalculateMonthlyEffortForPersonInProject(personId, startDate, endDate, projectId);

        // Obtener el esfuerzo total para el mes
        decimal totalEffort = monthlyEffort.Values.Sum();

        return totalEffort;
    }


    // Función para calcular LeaveReduction
    public async Task<decimal> CalculateLeaveReductionAsync(int personId, DateTime date, decimal totalHoursRequested)
    {
        // Buscar la afiliación de la persona para la fecha específica
        var affiliation = await _context.AffxPersons
            .FirstOrDefaultAsync(a => a.PersonId == personId && a.Start <= date && a.End >= date);

        if (affiliation == null)
        {
            throw new Exception($"No affiliation found for PersonId {personId} on {date}");
        }

        // Obtener las horas contractuales (100% del día) desde AffHours
        var affHours = await _context.AffHours
            .FirstOrDefaultAsync(ah => ah.AffId == affiliation.AffId && ah.StartDate <= date && ah.EndDate >= date);

        if (affHours == null)
        {
            throw new Exception($"No working hours found for AffId {affiliation.AffId}");
        }

        // Calcular el porcentaje del día trabajado
        var fullDayHours = affHours.Hours; // Horas contractuales del día
        if (fullDayHours <= 0)
        {
            throw new Exception($"Invalid working hours ({fullDayHours}) for AffId {affiliation.AffId}");
        }

        // Asegurarse de que LeaveReduction no sea mayor que 1
        var leaveReduction = Math.Min(totalHoursRequested / fullDayHours, 1.00m);

        return Math.Round(leaveReduction, 2); // Redondear a dos decimales
    }

    // Método auxiliar para redondear al entero o .5 más cercano
    private decimal RoundToNearestHalfOrWhole(decimal value)
    {
        // Multiplicar por 2, redondear al entero más cercano y dividir por 2
        return Math.Round(value * 2, MidpointRounding.AwayFromZero) / 2;
    }

    // Calcula las horas estimadas de una persona en un proyecto
    public async Task<decimal> CalculateEstimatedHoursForPersonInProject(int personId, int projectId, int year, int month)
    {
        // Obtener las horas totales trabajadas por la persona en el mes
        var hoursPerDayWithDedication = await CalculateDailyWorkHoursWithDedication(personId, year, month);
        var totalMonthlyHours = hoursPerDayWithDedication.Values.Sum();

        if (totalMonthlyHours == 0)
        {
            return 0; // Si no hay horas trabajadas, devolver 0
        }

        // Obtener los esfuerzos para los Work Packages del proyecto en el mes especificado
        var efforts = await _context.Persefforts
            .Include(pe => pe.WpxPersonNavigation)
            .Where(pe => pe.WpxPersonNavigation.Person == personId &&
                         pe.WpxPersonNavigation.WpNavigation.ProjId == projectId &&
                         pe.Month.Year == year &&
                         pe.Month.Month == month)
            .ToListAsync();

        // Calcular el esfuerzo total
        decimal totalEffort = efforts.Sum(e => e.Value);

        if (totalEffort == 0)
        {
            return 0; // Si no hay esfuerzo registrado, devolver 0
        }

        // Calcular las horas estimadas en el proyecto
        decimal estimatedHours = totalMonthlyHours * totalEffort;

        // Redondear al entero o .5 más cercano
        return RoundToNearestHalfOrWhole(estimatedHours);
    }

    // Calcula las horas estimadas de una persona en un proyecto y en un paquete de trabajo específico
    public async Task<decimal> CalculateEstimatedHoursForPersonInWorkPackage(int personId, int wpId, int year, int month)
    {
        // Obtener las horas totales trabajadas por la persona en el mes
        var hoursPerDayWithDedication = await CalculateDailyWorkHoursWithDedication(personId, year, month);
        var totalMonthlyHours = hoursPerDayWithDedication.Values.Sum();

        if (totalMonthlyHours == 0)
        {
            return 0; // Si no hay horas trabajadas, devolver 0
        }

        // Obtener los esfuerzos para el Work Package específico en el mes especificado
        var efforts = await _context.Persefforts
            .Where(pe => pe.WpxPersonNavigation.Person == personId &&
                                    pe.WpxPersonNavigation.Wp == wpId &&
                                                            pe.Month.Year == year &&
                                                                                    pe.Month.Month == month)
            .ToListAsync();

        // Calcular el esfuerzo total
        decimal totalEffort = efforts.Sum(e => e.Value);

        if (totalEffort == 0)
        {
            return 0; // Si no hay esfuerzo registrado, devolver 0
        }

        // Calcular las horas estimadas en el paquete de trabajo
        decimal estimatedHours = totalMonthlyHours * totalEffort;

        // Redondear al entero o .5 más cercano
        return RoundToNearestHalfOrWhole(estimatedHours);
    }

    public async Task<string> AdjustEffortAsync(int wpId, int personId, DateTime month)
    {
        // Inicio del mes y fin del mes
        DateTime startOfMonth = new DateTime(month.Year, month.Month, 1);
        DateTime endOfMonth = startOfMonth.AddMonths(1).AddDays(-1);

        // Validar si hay horas registradas en Timesheets
        var wpxPerson = await _context.Wpxpeople
            .FirstOrDefaultAsync(wpx => wpx.Wp == wpId && wpx.Person == personId);

        if (wpxPerson == null)
        {
            return "Error: No se encontró la relación entre la persona y el paquete de trabajo.";
        }

        var totalHoursInTimesheets = await _context.Timesheets
            .Where(ts => ts.WpxPersonId == wpxPerson.Id && ts.Day >= startOfMonth && ts.Day <= endOfMonth)
            .SumAsync(ts => (decimal?)ts.Hours) ?? 0;

        if (totalHoursInTimesheets == 0)
        {
            return "Error: No hay horas registradas para esta persona en este paquete de trabajo y mes.";
        }

        // Obtener el máximo de horas para la persona en el mes usando la nueva función
        decimal maxHours = await CalculateMaxHoursForPersonInMonth(personId, month.Year, month.Month);

        if (maxHours == 0)
        {
            return "Error: No se encontraron horas máximas definidas para las afiliaciones de esta persona.";
        }

        // Calcular el porcentaje de esfuerzo
        decimal effortPercentage = totalHoursInTimesheets / maxHours;

        // Ajustar o crear el registro en Perseffort
        var existingEffort = await _context.Persefforts
            .FirstOrDefaultAsync(pe => pe.WpxPerson == wpxPerson.Id && pe.Month == startOfMonth);

        if (existingEffort != null)
        {
            existingEffort.Value = effortPercentage;
            _context.Persefforts.Update(existingEffort);
        }
        else
        {
            var newEffort = new Perseffort
            {
                WpxPerson = wpxPerson.Id,
                Month = startOfMonth,
                Value = effortPercentage
            };
            _context.Persefforts.Add(newEffort);
        }

        await _context.SaveChangesAsync();

        return $"Éxito: El esfuerzo para la persona {personId} en el paquete de trabajo {wpId} ha sido ajustado al {effortPercentage:P2} para el mes {month:MMMM yyyy}.";
    }

    
    public async Task<decimal> CalculateMaxHoursForPersonInMonth(int personId, int year, int month)
    {
        // Obtener afiliaciones activas de la persona para el mes
        var affiliations = await _context.AffxPersons
            .Where(ap => ap.PersonId == personId && ap.Start <= new DateTime(year, month, DateTime.DaysInMonth(year, month)) && ap.End >= new DateTime(year, month, 1))
            .Select(ap => new
            {
                ap.AffId,
                StartDate = ap.Start,
                EndDate = ap.End
            })
            .ToListAsync();

        if (!affiliations.Any())
        {
            return 0; // No hay afiliaciones activas
        }

        // Caso de una sola afiliación que cubre todo el mes
        if (affiliations.Count == 1 && affiliations[0].StartDate <= new DateTime(year, month, 1))
        {
            var dailyHours = await _context.AffHours
                .Where(ah => ah.AffId == affiliations[0].AffId && ah.StartDate <= new DateTime(year, month, DateTime.DaysInMonth(year, month)) && ah.EndDate >= new DateTime(year, month, 1))
                .Select(ah => ah.Hours)
                .FirstOrDefaultAsync();

            if (dailyHours > 0)
            {
                int workingDays = await GetWorkingDaysInMonth(year, month);
                return workingDays * dailyHours;
            }
        }

        decimal totalMaxHours = 0;

        // Iterar por cada día del mes para múltiples afiliaciones
        DateTime startOfMonth = new DateTime(year, month, 1);
        DateTime endOfMonth = startOfMonth.AddMonths(1).AddDays(-1);
        for (DateTime currentDay = startOfMonth; currentDay <= endOfMonth; currentDay = currentDay.AddDays(1))
        {
            // Saltar sábados, domingos y días festivos
            var nationalHolidays = await _context.NationalHolidays
                .Where(nh => nh.Date >= startOfMonth && nh.Date <= endOfMonth)
                .Select(nh => nh.Date)
                .ToListAsync();

            if (currentDay.DayOfWeek == DayOfWeek.Saturday || currentDay.DayOfWeek == DayOfWeek.Sunday || nationalHolidays.Contains(currentDay))
            {
                continue;
            }

            // Determinar la afiliación activa para el día
            var activeAffiliation = affiliations
                .FirstOrDefault(aff => aff.StartDate <= currentDay && aff.EndDate >= currentDay);

            if (activeAffiliation != null)
            {
                // Obtener las horas diarias de la afiliación activa
                var dailyHours = await _context.AffHours
                    .Where(ah => ah.AffId == activeAffiliation.AffId && ah.StartDate <= currentDay && ah.EndDate >= currentDay)
                    .Select(ah => ah.Hours)
                    .FirstOrDefaultAsync();

                if (dailyHours > 0)
                {
                    totalMaxHours += dailyHours;
                }
            }
        }

        return totalMaxHours;
    }

    public async Task<int> GetWorkingDaysInMonth(int year, int month)
    {
        // Fecha de inicio y fin del mes
        DateTime startOfMonth = new DateTime(year, month, 1);
        DateTime endOfMonth = startOfMonth.AddMonths(1).AddDays(-1);

        // Obtener días festivos nacionales
        var nationalHolidays = await _context.NationalHolidays
            .Where(nh => nh.Date >= startOfMonth && nh.Date <= endOfMonth)
            .Select(nh => nh.Date)
            .ToListAsync();

        int workingDays = 0;

        // Iterar por cada día del mes
        for (DateTime currentDay = startOfMonth; currentDay <= endOfMonth; currentDay = currentDay.AddDays(1))
        {
            // Contar solo días laborables
            if (currentDay.DayOfWeek != DayOfWeek.Saturday && currentDay.DayOfWeek != DayOfWeek.Sunday && !nationalHolidays.Contains(currentDay))
            {
                workingDays++;
            }
        }

        return workingDays;
    }

    public async Task AutoFillTimesheetForPersonAndMonthAsync(int personId, DateTime targetMonth)
    {
        var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", $"AutoFillTimesheet_{personId}_{targetMonth:yyyyMM}.txt");
        var logger = new LoggerConfiguration()
            .MinimumLevel.Debug()
            .WriteTo.File(logPath, rollingInterval: RollingInterval.Infinite)
            .CreateLogger();

        try
        {
            var monthStart = new DateTime(targetMonth.Year, targetMonth.Month, 1);
            var monthEnd = monthStart.AddMonths(1).AddDays(-1);

            logger.Information($"Inicio del proceso para el empleado {personId} en el mes {monthStart:yyyy-MM}");

            var wpxList = await _context.Wpxpeople
                .Include(w => w.PersonNavigation)
                .Include(w => w.WpNavigation)
                    .ThenInclude(wp => wp.Proj)
                .Where(w => w.Person == personId)
                .ToListAsync();

            var wpxWithEffort = await _context.Persefforts
                    .Where(pe => pe.Month == monthStart && wpxList.Select(w => w.Id).Contains(pe.WpxPerson) && pe.Value > 0)
                    .OrderByDescending(pe => pe.Value)
                    .Select(pe => pe.WpxPerson)
                    .FirstOrDefaultAsync();


            if (wpxWithEffort == 0)
            {
                logger.Warning($"Empleado {personId} no tiene effort registrado en {monthStart:yyyy-MM}");
                return;
            }

            var wpx = wpxList.FirstOrDefault(w => w.Id == wpxWithEffort);
            if (wpx == null)
            {
                logger.Warning($"Error al obtener WP con effort para el empleado {personId} en {monthStart:yyyy-MM}");
                return;
            }

            var personName = wpx.PersonNavigation.Name ?? "SIN NOMBRE";
            var personSurname = wpx.PersonNavigation.Surname ?? "SIN APELLIDO";
            var projectAcronym = wpx.WpNavigation?.Proj?.Acronim ?? "SIN PROYECTO";

            var monthlyEffort = await _context.Persefforts
                .Where(pe => pe.WpxPerson == wpx.Id && pe.Month == monthStart)
                .SumAsync(pe => pe.Value);

            if (monthlyEffort <= 0)
            {
                logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: Effort es 0 o negativo");
                return;
            }

            var maxEffort = await _context.PersMonthEfforts
                .Where(pme => pme.PersonId == personId && pme.Month == monthStart)
                .Select(pme => pme.Value)
                .FirstOrDefaultAsync();

            if (monthlyEffort > maxEffort)
            {
                logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - WP={wpx.Wp}, Mes={monthStart:yyyy-MM}: Ajuste de {monthlyEffort} a {maxEffort}");
                monthlyEffort = maxEffort;
            }

            bool ajusteCompleto = Math.Abs(monthlyEffort - maxEffort) <= 0.001m;

            var validWorkDays = Enumerable.Range(0, (monthEnd - monthStart).Days + 1)
                .Select(offset => monthStart.AddDays(offset))
                .Where(day => day.DayOfWeek != DayOfWeek.Saturday && day.DayOfWeek != DayOfWeek.Sunday)
                .ToList();

            validWorkDays = validWorkDays
                .Where(day => !IsHoliday(day).Result)
                .ToList();

            var leaveDays = await _context.Leaves
                .Where(l => l.PersonId == personId && l.Day >= monthStart && l.Day <= monthEnd && (l.Type == 1 || l.Type == 2 || l.Type == 3))
                .Select(l => l.Day)
                .ToListAsync();

            validWorkDays = validWorkDays.Except(leaveDays).ToList();

            if (!validWorkDays.Any())
            {
                logger.Warning($"[{personName} {personSurname}] [{projectAcronym}] - No hay días hábiles disponibles");
                return;
            }

            // Detectar si la persona tiene dedicación activa todo el mes
            bool worksWholeMonth = await _context.Dedications
                .AnyAsync(d => d.PersId == personId &&
                               d.Type != 0 &&
                               d.Start <= monthStart &&
                               (d.End == null || d.End >= monthEnd));

            decimal maxHoursForMonth;

            if (worksWholeMonth)
            {
                maxHoursForMonth = await CalculateMaxHoursForPersonInMonth(personId, monthStart.Year, monthStart.Month);
                logger.Information($"[{personName} {personSurname}] Se detecta mes completo. Cálculo real con días hábiles y bajas.");
            }
            else
            {
                maxHoursForMonth = await CalculateTheoreticalMonthlyHoursAsync(personId, monthStart.Year, monthStart.Month);
                logger.Information($"[{personName} {personSurname}] Dedicación parcial. Cálculo teórico con effort aplicado sobre mes completo.");
            }

            decimal totalMonthlyHours = ajusteCompleto ? maxHoursForMonth * maxEffort : monthlyEffort * maxHoursForMonth;
            //decimal totalMonthlyHours = ajusteCompleto ? maxHoursForMonth : monthlyEffort * maxHoursForMonth;
            decimal rawDailyHours = totalMonthlyHours / validWorkDays.Count;
            //decimal adjustedDailyHours = Math.Round(rawDailyHours * 2, MidpointRounding.AwayFromZero) / 2; // ANTERIOR AL CAMBIO DECIMAL
            decimal adjustedDailyHours = Math.Round(rawDailyHours, 1, MidpointRounding.AwayFromZero);

            if (adjustedDailyHours == 0) adjustedDailyHours = 0.5m;

            foreach (var day in validWorkDays)
            {
                var timesheet = await _context.Timesheets
                    .FirstOrDefaultAsync(ts => ts.WpxPersonId == wpx.Id && ts.Day == day);

                if (timesheet == null)
                {
                    _context.Timesheets.Add(new Timesheet
                    {
                        WpxPersonId = wpx.Id,
                        Day = day,
                        Hours = adjustedDailyHours
                    });
                    logger.Information($"[{personName} {personSurname}] Día {day:yyyy-MM-dd}: nuevo registro con {adjustedDailyHours} horas");
                }
                else
                {
                    decimal previous = timesheet.Hours;
                    timesheet.Hours = adjustedDailyHours;
                    logger.Information($"[{personName} {personSurname}] Día {day:yyyy-MM-dd}: actualizado de {previous} a {adjustedDailyHours} horas");
                }
            }

            await _context.SaveChangesAsync();
            logger.Information($"Finalizado para el empleado {personId} en {monthStart:yyyy-MM}");
        }
        catch (Exception ex)
        {
            logger.Error($"Error en AutoFillTimesheetForPersonAndMonthAsync: {ex.Message}");
        }
        finally
        {
            logger.Dispose();
        }
    }

    public async Task<bool> HasNoContractDaysAsync(int personId, int year, int month)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        var hasNoContract = await _context.Leaves.AnyAsync(l =>
            l.PersonId == personId &&
            l.Day >= startDate &&
            l.Day <= endDate &&
            l.Type == 3 // tipo "no contrato"
        );

        return hasNoContract;
    }


    public async Task<decimal> CalculateMaxHoursByAffiliationOnlyAsync(int personId, int year, int month)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        // Buscar afiliación válida para ese mes
        var affx = await _context.AffxPersons
            .Where(ap => ap.PersonId == personId &&
                         ap.Start <= endDate &&
                         ap.End >= startDate)
            .OrderByDescending(ap => ap.Start) // Por si hay varias, tomar la más reciente
            .FirstOrDefaultAsync();

        if (affx == null)
            return 0;

        int affId = affx.AffId;

        // Buscar las horas asociadas a esa afiliación
        var affHours = await _context.AffHours
            .Where(ah => ah.AffId == affId &&
                         ah.StartDate <= endDate &&
                         ah.EndDate >= startDate)
            .OrderByDescending(ah => ah.StartDate)
            .FirstOrDefaultAsync();

        if (affHours == null)
            return 0;

        // Calcular días laborables
        int workingDays = await CalculateWorkingDays(year, month);

        return Math.Round(affHours.Hours * workingDays, 2);
    }



    
    // Esta función ajusta automáticamente los efforts mensuales de una persona para corregir overloads respetando viajes y bloqueos
    public async Task<(bool Success, string Message)> AdjustMonthlyOverloadAsync(int personId, int year, int month)
    {
        
        var result = (Success: false, Message: "");

        var logPath = Path.Combine(Directory.GetCurrentDirectory(), "Logs", $"AdjustMonthlyOverloadLog_{DateTime.Now:yyyyMMdd}.txt");
        var logger = new LoggerConfiguration()
            .MinimumLevel.Debug()
            .WriteTo.File(logPath, rollingInterval: RollingInterval.Day)
            .CreateLogger();

        logger.Information("🧮 Iniciando evaluacion de ajuste de overload para Persona {PersonId} en {Month}/{Year}", personId, month, year);

        // Buscar el PM máximo permitido para esa persona y mes
        var pmEntry = await _context.PersMonthEfforts
                        .FirstOrDefaultAsync(p => p.PersonId == personId && p.Month.Year == year && p.Month.Month == month);

        // Si no hay PM registrado, no se puede continuar
        if (pmEntry == null)
        {
            logger.Warning("No se encontró entrada de PM para Persona {PersonId} en {Month}/{Year}", personId, month, year);
            return (false, "No PM value found for the specified month.");
        }
        var pmValue = pmEntry.Value;

        // Definir las fechas de inicio y fin del mes
        DateTime monthStart = new DateTime(year, month, 1);
        DateTime monthEnd = monthStart.AddMonths(1).AddDays(-1);

        // Obtener todos los efforts de la persona ese mes
        var efforts = await _context.Persefforts
            .Include(pe => pe.WpxPersonNavigation)
            .ThenInclude(wpx => wpx.WpNavigation)
            .ThenInclude(wp => wp.Proj)
            .Where(pe => pe.WpxPersonNavigation.Person == personId &&
                         pe.Month.Year == year && pe.Month.Month == month)
            .ToListAsync();

        // Si no hay efforts, no hay nada que ajustar
        if (!efforts.Any())
        {
            logger.Warning("No se encontraron efforts para Persona {PersonId} en {Month}/{Year}", personId, month, year);
            return (false, "No efforts found for this person and month.");
        }
        // Guardar los valores originales de los efforts antes de resetearlos
        var originalEffortValues = efforts.ToDictionary(e => e.Code, e => e.Value);

        // Agrupar efforts por proyecto y WP para analizarlos por separado
        var grouped = efforts
            .GroupBy(e => new { ProjId = e.WpxPersonNavigation.WpNavigation.ProjId, WpId = e.WpxPersonNavigation.Wp })
            .Select(g => new
            {
                ProjId = g.Key.ProjId,
                WpId = g.Key.WpId,
                TotalEffort = g.Sum(x => x.Value),
                Persefforts = g.ToList()
            }).ToList();

        // Calcular el total de effort actualmente alocado
        var totalAllocated = grouped.Sum(g => g.TotalEffort);
        logger.Information("Total effort asignado: {TotalAllocated}, PM permitido: {PM}", totalAllocated, pmValue);
        if (totalAllocated <= pmValue)
        {
            logger.Information("No hay overload. El esfuerzo total ({TotalAllocated}) no supera el PM ({PM})", totalAllocated, pmValue);
            return (true, "No overload found.");
        }
        var overload = totalAllocated - pmValue; // Calcula cuánto sobra
        

        // Buscar los proyectos bloqueados para esa persona y mes que no se pueden modificar
        var lockedProjects = await _context.ProjectMonthLocks
            .Where(l => l.PersonId == personId && l.Year == year && l.Month == month && l.IsLocked)
            .Select(l => l.ProjectId)
            .ToListAsync();

        // Identificar efforts bloqueados
        var lockedEfforts = grouped.Where(g => lockedProjects.Contains(g.ProjId)).ToList();

        // Calcular effort total bloqueado y disponible
        var lockedEffortTotal = lockedEfforts.Sum(g => g.TotalEffort);
        var availableEffort = pmValue - lockedEffortTotal;
        

        // Si lo bloqueado ya supera el PM, no se puede resolver
        if (availableEffort < 0)
        {
            logger.Error("Los efforts bloqueados superan el PM disponible. Ajuste no posible.");
            return (false, "Locked efforts exceed available PM. Overload cannot be resolved.");
        }
        // Filtrar los efforts que sí se pueden modificar
        var modifiableEfforts = grouped.Except(lockedEfforts).ToList();

        // Obtener los viajes aceptados en ese mes para esa persona
        var travels = await _context.Liquidations
            .Where(t => t.PersId == personId && t.Start <= monthEnd && t.End >= monthStart)
            .Select(t => t.Id)
            .ToListAsync();

        // Obtener los IDs
        var travelProjIds = await _context.liqdayxproject
        .Where(l => travels.Contains(l.LiqId) && l.Day >= monthStart && l.Day <= monthEnd)
        .Select(l => l.ProjId)
        .Distinct()
        .ToListAsync(); // Obtiene los Proyectos afectados por viajes /

        // Agrupar esos WPs por proyecto
        var withTravelGroupedByProject = modifiableEfforts
        .Where(g => travelProjIds.Contains(g.ProjId))
        .GroupBy(g => g.ProjId)
        .ToList(); // Agrupa por proyecto los WPs con viajes

        var minEffortByProject = new Dictionary<int, decimal>(); // Diccionario de esfuerzo mínimo requerido por proyecto

        // Calcular el mínimo effort requerido por proyecto para justificar los viajes
        foreach (var projectGroup in withTravelGroupedByProject)
        {
            int projId = projectGroup.Key;
            var travelEffort = await _context.liqdayxproject
                .Where(l => l.PersId == personId &&
                            l.ProjId == projId &&
                            l.Day >= monthStart && l.Day <= monthEnd)
                .SumAsync(l => l.PMs);

            minEffortByProject[projId] = travelEffort; // Guarda el mínimo por proyecto            
        }

        // Sumar todos los efforts mínimos por viajes
        var minTotalTravelEffort = minEffortByProject.Values.Sum(); // Suma total de esfuerzo mínimo requerido por viajes
        if (availableEffort < minTotalTravelEffort) // Si no hay suficiente disponible, salir
        {
            logger.Error("El esfuerzo disponible no alcanza para cubrir el mínimo por viajes ({MinRequired})", minTotalTravelEffort);
            return (false, "Available PM is not enough to justify travel-related efforts.");
        }

        
        // Calcular el esfuerzo total a reducir y el ratio de reducción general
        decimal totalEffortToReduce = modifiableEfforts.Sum(m => m.TotalEffort); // Total que se podría ajustar
        decimal targetEffort = availableEffort; // Esfuerzo que realmente podemos usar
        decimal reductionRatio = Math.Min(1.0m, targetEffort / totalEffortToReduce); // Ratio general de reducción

        // Enfoque iterativo: ajustamos individualmente los proyectos con viaje que no pueden aceptar el ratio global,
        // y una vez viable, aplicamos el ratio a todos los que sí pueden aceptarlo
        var remainingTravelEfforts = withTravelGroupedByProject.ToList(); // Lista inicial de proyectos con viaje por tratar
                                                                          
        var treatedProjects = new HashSet<int>();// Conjunto para registrar los IDs de proyectos ya ajustados por viaje (personalizado o global)

        logger.Information("=== INICIO Ajuste Mensual por Overload ===");
        logger.Information($"Persona: {personId}, Mes evaluado: {new DateTime(year, month, 1):yyyy-MM}");
        logger.Information($"PM permitido: {pmValue:F2}, Esfuerzo total detectado: {totalAllocated:F2}, Overload: {overload:F2}");
        logger.Information($"Effort bloqueado (proyectos bloqueados): {lockedEffortTotal:F2}, Esfuerzo disponible para ajustes: {availableEffort:F2}");

        logger.Information("--- Proyectos bloqueados ---");
        foreach (var b in lockedEfforts)
            logger.Information($"[BLOQUEADO] Proyecto {b.ProjId}, TotalEffort={b.TotalEffort:F2}");

        logger.Information("--- Proyectos modificables con viaje ---");
        foreach (var g in withTravelGroupedByProject)
        {
            int projId = g.Key;
            var originalEffort = g.SelectMany(wp => wp.Persefforts).Sum(e => originalEffortValues[e.Code]);
            logger.Information($"[VIAJE] Proyecto {projId}, Effort Original Total: {originalEffort:F2}, Mínimo requerido por viaje: {minEffortByProject[projId]:F2}");
        }

        while (true)
        {
            // Identificar proyectos que no cumplen con el mínimo usando el ratio global aplicado effort por effort
            var nonCompliantProjects = remainingTravelEfforts
                .Where(projectGroup =>
                {
                    int projId = projectGroup.Key;
                    var projectedTotal = projectGroup.SelectMany(wp => wp.Persefforts)
                        .Sum(e => Math.Round(originalEffortValues[e.Code] * reductionRatio, 2));
                    return projectedTotal < minEffortByProject[projId];
                })
                .ToList();

            if (!nonCompliantProjects.Any())
            {
                logger.Information("✔ Todos los proyectos con viaje restantes cumplen con el ratio global actual.");
                break;
            }

            // Para cada proyecto no compatible, aplicar ratio mínimo necesario individualmente
            foreach (var projectGroup in nonCompliantProjects)
            {
                int projId = projectGroup.Key;
                decimal minEffort = minEffortByProject[projId];
                var allEfforts = projectGroup.SelectMany(wp => wp.Persefforts).ToList();

                var totalOriginal = allEfforts.Sum(e => originalEffortValues[e.Code]);

                logger.Information($"--- Ajuste Proyecto {projId} (personalizado) ---");
                logger.Information($"Esfuerzo original total: {totalOriginal:F2}, Mínimo requerido por viaje: {minEffort:F2}");


                if (totalOriginal == 0)
                {
                    logger.Error($"❌ Proyecto {projId} tiene esfuerzo original 0 pero requiere mínimo {minEffort}");
                    return (false, $"Project {projId} has zero original effort but requires travel effort.");
                }

                decimal projRatio = minEffort / totalOriginal;

                Console.WriteLine($"=== Ajustando Proyecto {projId} ===");
                Console.WriteLine($"- Ratio global original: {reductionRatio}");
                Console.WriteLine($"- No acepta el ratio global. Se aplica ratio personalizado: {projRatio}");
                Console.WriteLine($"- Esfuerzo requerido para viaje: {minEffort}");
                Console.WriteLine($"- Total effort original del proyecto: {totalOriginal}");

                decimal totalAdjusted = 0;
                var orderedEfforts = allEfforts.OrderBy(e => originalEffortValues[e.Code]).ToList();

                foreach (var effort in orderedEfforts)
                {
                    var original = originalEffortValues[effort.Code];
                    var newEffort = Math.Round(original * projRatio, 2);
                    effort.Value = newEffort;
                    totalAdjusted += newEffort;
                    logger.Information($"  Effort {effort.Code}: original={original:F2} → ajustado={newEffort:F2}");
                }

                // Delta final
                var delta = Math.Round(minEffort, 2) - totalAdjusted;
                if (delta != 0 && orderedEfforts.Any())
                {
                    var maxEffort = allEfforts
                                    .OrderByDescending(e => originalEffortValues[e.Code])
                                    .FirstOrDefault();
                    if (maxEffort != null)
                        maxEffort.Value += delta;
                    logger.Information($"  → Delta aplicado al último effort {orderedEfforts.Last().Code}: +{delta:F2}");
                }

                var finalSum = orderedEfforts.Sum(e => e.Value);
                logger.Information($"Total final asignado al proyecto: {finalSum:F2}");

                if (finalSum < minEffort)
                    logger.Warning($"❌ El total final no cumple con el mínimo ({finalSum:F2} < {minEffort:F2})");
                else
                    logger.Information($"✅ Mínimo cumplido correctamente ({finalSum:F2} ≥ {minEffort:F2})");

                availableEffort -= minEffort;
                // Marcar este proyecto como tratado
                treatedProjects.Add(projId);

            }


            remainingTravelEfforts = remainingTravelEfforts.Except(nonCompliantProjects).ToList();
            totalEffortToReduce = modifiableEfforts.SelectMany(m => m.Persefforts).Sum(e => originalEffortValues[e.Code]) - (pmValue - availableEffort);
            reductionRatio = Math.Min(1.0m, availableEffort / totalEffortToReduce);
            logger.Information($"↪ Nuevo ratio global recalculado: {reductionRatio:F6}, con esfuerzo restante: {availableEffort:F2}");
        }
                
        // Ajustamos el resto de proyectos con viaje usando el ratio global validado
        foreach (var projectGroup in remainingTravelEfforts)
        {
            int projId = projectGroup.Key;
            var minEffort = minEffortByProject.ContainsKey(projId) ? minEffortByProject[projId] : 0;
            var allEfforts = projectGroup.SelectMany(wp => wp.Persefforts).ToList();
            var totalOriginal = allEfforts.Sum(e => originalEffortValues[e.Code]);
            // ⚠️ IMPORTANTE: Calculamos idealTotal sumando los efforts ya redondeados individualmente.
            // Esto evita errores acumulados por redondeos tardíos como Math.Round(suma * ratio, 2),
            // que pueden producir diferencias de ±0.01 incluso si los valores individuales son correctos.
            // Este enfoque asegura consistencia con la forma en que realmente se aplican los efforts.
            var idealTotal = allEfforts.Sum(e => Math.Round(originalEffortValues[e.Code] * reductionRatio, 2));



            logger.Information($"--- Ajuste Proyecto {projId} (ratio global) ---");
            logger.Information($"Total esfuerzo original: {totalOriginal:F2}, Ratio global aplicado: {reductionRatio:F6}");
            logger.Information($"Ideal total esperado tras ajuste: {idealTotal:F2}");
            if (minEffort > 0)
                logger.Information($"Mínimo requerido por viaje: {minEffort:F2}");

            decimal totalAdjusted = 0;

            var orderedEfforts = allEfforts.OrderBy(e => originalEffortValues[e.Code]).ToList();
            foreach (var effort in orderedEfforts)
            {
                var original = originalEffortValues[effort.Code];
                var newEffort = Math.Round(original * reductionRatio, 2);
                effort.Value = newEffort;
                totalAdjusted += newEffort;
                logger.Information($"  Effort {effort.Code}: original={original:F2} → ajustado={newEffort:F2}");
            }

            var delta = idealTotal - totalAdjusted;
            if (delta != 0 && orderedEfforts.Any())
            {
                var maxEffort = allEfforts
                                .OrderByDescending(e => originalEffortValues[e.Code])
                                .FirstOrDefault();
                if (maxEffort != null)
                    maxEffort.Value += delta;
                logger.Information($"  → Delta aplicado al último effort {orderedEfforts.Last().Code}: +{delta:F2}");
            }

            var finalSum = orderedEfforts.Sum(e => e.Value);
            logger.Information($"Total final ajustado del proyecto: {finalSum:F2}");

            if (minEffort > 0 && finalSum < minEffort)
                logger.Warning($"❌ NO SE CUMPLE el mínimo requerido ({finalSum:F2} < {minEffort:F2})");
            else if (minEffort > 0)
                logger.Information($"✅ Mínimo cumplido correctamente ({finalSum:F2} ≥ {minEffort:F2})");

            // 🔄 Restar del esfuerzo disponible el total ajustado de este proyecto
            availableEffort -= finalSum;

            // Marcar este proyecto como tratado
            treatedProjects.Add(projId);
        }

        logger.Information("=== Proyectos tratados ===");
        foreach (var id in treatedProjects)
            logger.Information($"Tratado: ProjId {id}");


        logger.Information("=== Ajuste de proyectos sin viajes (withoutTravel) ===");
        // Ahora tratamos los efforts sin viajes ni ajustes anteriores de forma global (ordenados de menor a mayor effort)
        var withoutTravel = modifiableEfforts
            .Where(g => !treatedProjects.Contains(g.ProjId)) // Excluimos también proyectos ya tratados
            .ToList();
        logger.Information("=== Proyectos en withoutTravel ===");
        foreach (var wp in withoutTravel)
            logger.Information($"Incluido: Proyecto {wp.ProjId} - WP {wp.WpId} - Effort total: {wp.TotalEffort:F2}");

        decimal remainingEffort = availableEffort; // Ya fue calculado correctamente antes
        

        var totalWithoutTravel = withoutTravel.Sum(w => w.TotalEffort);
        logger.Information($"Esfuerzo restante disponible para ajustes sin viajes: {remainingEffort:F2}");

        if (totalWithoutTravel > 0 && remainingEffort > 0)
        {
            var ratio = Math.Min(1.0m, remainingEffort / totalWithoutTravel);
            logger.Information($"Aplicando ratio global sin viajes: {ratio:F6}");
            var allEfforts = withoutTravel.SelectMany(wp => wp.Persefforts).ToList();

            decimal totalAdjusted = 0;
            foreach (var effort in allEfforts)
            {
                var originalValue = originalEffortValues[effort.Code];
                var newEffort = Math.Round(originalEffortValues[effort.Code] * ratio, 2);
                effort.Value = newEffort;
                totalAdjusted += newEffort;
                logger.Information($"  Effort {effort.Code}: original={originalValue:F2} → ajustado={newEffort:F2}");
            }

            var delta = Math.Round(remainingEffort, 2) - totalAdjusted; // Compensamos la diferencia final exacta
            if (delta != 0 && allEfforts.Any())
            {
                var maxEffort = allEfforts
                    .OrderByDescending(e => originalEffortValues[e.Code])
                    .FirstOrDefault();
                if (maxEffort != null)
                {
                    maxEffort.Value += delta;
                    logger.Information($"  → Delta aplicado al último effort {allEfforts.Last().Code}: +{delta:F2}");
                }
            }
            logger.Information($"Total ajustado en proyectos sin viaje: {totalAdjusted + delta:F2}");

        }
        else
        {
            logger.Information("No hay esfuerzos sin viajes para ajustar o no hay esfuerzo restante disponible.");
        }
        // Validación final: comprobar si el esfuerzo total corregido no excede el PM permitido
        var adjustedEfforts = modifiableEfforts.SelectMany(g => g.Persefforts).ToList();
        var totalEffortFinal = lockedEfforts.Sum(g => g.TotalEffort) + adjustedEfforts.Sum(e => e.Value);
        var excess = Math.Round(totalEffortFinal - pmValue, 2);

        logger.Information($"Total esfuerzo final ajustado: {totalEffortFinal:F2}, PM permitido: {pmValue:F2}");

        if (excess > 0) // Tolerancia mínima
        {
            var maxEffort = adjustedEfforts.OrderByDescending(e => e.Value).FirstOrDefault();
            if (maxEffort != null)
            {
                logger.Warning($"Se detecta exceso de {excess:F2} sobre el PM. Ajustando último effort...");
                maxEffort.Value = Math.Max(0, Math.Round(maxEffort.Value - excess, 2));
                totalEffortFinal = lockedEfforts.Sum(g => g.TotalEffort) + adjustedEfforts.Sum(e => e.Value);
                logger.Information($"Nuevo total tras corrección del exceso: {totalEffortFinal:F2}");
            }
        }

        if (Math.Round(totalEffortFinal, 2) > Math.Round(pmValue, 2))
        {
            logger.Error($"❌ El esfuerzo final ajustado ({totalEffortFinal:F2}) excede el PM permitido ({pmValue:F2})");
            return (false, $"Adjusted total effort ({totalEffortFinal}) exceeds available PM ({pmValue}).");
        }

        logger.Information("✅ Ajuste completado correctamente. Guardando en base de datos...");
        // Guardar todos los cambios en la base de datos
        await _context.SaveChangesAsync();

        logger.Information("=== Ajuste mensual completado con éxito ===");

        return (true, "Overload corrected successfully.");

        logger.Information("=== Resumen Final del Ajuste de Esfuerzo ===");

        var groupedFinal = adjustedEfforts
            .GroupBy(e => new
            {
                ProjId = e.WpxPersonNavigation.WpNavigation.ProjId,
                WpId = e.WpxPersonNavigation.WpNavigation.Id
            })
            .Select(g => new
            {
                ProjId = g.Key.ProjId,
                WpId = g.Key.WpId,
                TotalAdjusted = g.Sum(x => x.Value),
                Lines = g.Select(x => new
                {
                    Code = x.Code,
                    Original = originalEffortValues[x.Code],
                    Final = x.Value
                }).ToList()
            });

        foreach (var wp in groupedFinal)
        {
            logger.Information($"Proyecto {wp.ProjId} - WP {wp.WpId} - Total ajustado: {wp.TotalAdjusted:F2}");
            foreach (var line in wp.Lines)
            {
                logger.Information($"    • Effort {line.Code}: original={line.Original:F2} → final={line.Final:F2}");
            }
        }

    }

    public async Task<bool> HasActiveContractAsync(int personId, DateTime date)
    {
        return await _context.Dedications
            .AnyAsync(d => d.PersId == personId && d.Start <= date && d.End >= date);
    }

    public async Task<bool> IsOverloadedAsync(int personId, int year, int month)
    {
        var effort = await CalculateMonthlyEffortForPerson(personId, year, month);
        var maxPM = await _context.PersMonthEfforts
            .Where(p => p.PersonId == personId && p.Month.Year == year && p.Month.Month == month)
            .Select(p => (decimal?)p.Value)
            .FirstOrDefaultAsync();

        return maxPM.HasValue && effort > maxPM.Value;
    }

    public async Task<decimal> CalculateGlobalHoursForMonth(int personId, int year, int month)
    {
        var daysWithDedication = await CalculateDailyWorkHoursWithDedication(personId, year, month);
        var leaves = await _context.Leaves
            .Where(l => l.PersonId == personId &&
                        l.Day.Year == year &&
                        l.Day.Month == month)
            .ToListAsync();

        var holidays = await _context.NationalHolidays
            .Where(h => h.Date.Year == year && h.Date.Month == month)
            .Select(h => h.Date)
            .ToListAsync();

        decimal totalHours = 0;

        foreach (var entry in daysWithDedication)
        {
            var day = entry.Key;
            var baseHours = entry.Value;

            if (holidays.Contains(day))
                continue;

            var leave = leaves.FirstOrDefault(l => l.Day.Date == day.Date);

            if (leave != null)
            {
                if (leave.Type == 11 || leave.Type == 12) // bajas parciales
                {
                    // Se asume que Leave.Reduction es un valor decimal (0.25, 0.5, etc.)
                    decimal reduction = leave.LeaveReduction;
                    decimal adjusted = Math.Round(baseHours * (1 - reduction), 2);
                    totalHours += adjusted;
                }
                else
                {
                    // bajas completas o vacaciones → se omite el día
                    continue;
                }
            }
            else
            {
                totalHours += baseHours;
            }
        }

        return Math.Round(totalHours, 2);
    }

    public async Task<decimal> CalculateGlobalHoursFast(int personId, int year, int month,
    List<Leave> preloadedLeaves,
    List<NationalHoliday> preloadedHolidays)
    {
        var daysWithDedication = await CalculateDailyWorkHoursWithDedication(personId, year, month);

        var leaves = preloadedLeaves
            .Where(l => l.PersonId == personId && l.Day.Year == year && l.Day.Month == month)
            .ToList();

        var holidays = preloadedHolidays
            .Where(h => h.Date.Year == year && h.Date.Month == month)
            .Select(h => h.Date)
            .ToHashSet();

        decimal totalHours = 0;

        foreach (var entry in daysWithDedication)
        {
            var day = entry.Key;
            var baseHours = entry.Value;

            if (holidays.Contains(day))
                continue;

            var leave = leaves.FirstOrDefault(l => l.Day.Date == day.Date);

            if (leave != null)
            {
                if (leave.Type == 11 || leave.Type == 12)
                {
                    decimal adjusted = Math.Round(baseHours * (1 - leave.LeaveReduction), 2);
                    totalHours += adjusted;
                }
                else
                {
                    continue; // baja completa o vacaciones
                }
            }
            else
            {
                totalHours += baseHours;
            }
        }

        return Math.Round(totalHours, 2);
    }

    public async Task<Dictionary<(int personId, int year, int month), Dictionary<DateTime, decimal>>> PreloadDailyWorkHoursWithDedicationAsync(List<int> personIds, int year)
    {
        var result = new Dictionary<(int personId, int year, int month), Dictionary<DateTime, decimal>>();

        // Precarga dedications y affiliations solo una vez para todos
        var dedications = await _context.Dedications
            .Where(d => personIds.Contains(d.PersId) &&
                        d.Start <= new DateTime(year, 12, 31) &&
                        d.End >= new DateTime(year, 1, 1))
            .ToListAsync();

        var affxpersons = await _context.AffxPersons
            .Include(ap => ap.Affiliation)
            .Where(ap => personIds.Contains(ap.PersonId) &&
                         ap.Start <= new DateTime(year, 12, 31) &&
                         ap.End >= new DateTime(year, 1, 1))
            .ToListAsync();

        var affIds = affxpersons.Select(ap => ap.AffId).Distinct().ToList();

        var affHours = await _context.AffHours
            .Where(ah => affIds.Contains(ah.AffId) &&
                         ah.StartDate <= new DateTime(year, 12, 31) &&
                         ah.EndDate >= new DateTime(year, 1, 1))
            .ToListAsync();

        // Precarga festivos del año
        var holidays = await _context.NationalHolidays
            .Where(h => h.Date.Year == year)
            .Select(h => h.Date)
            .ToListAsync();

        foreach (var personId in personIds)
        {
            var personAffiliations = affxpersons.Where(ap => ap.PersonId == personId).ToList();
            var personDedications = dedications.Where(d => d.PersId == personId).ToList();

            for (int month = 1; month <= 12; month++)
            {
                var startOfMonth = new DateTime(year, month, 1);
                var endOfMonth = startOfMonth.AddMonths(1).AddDays(-1);

                var days = new Dictionary<DateTime, decimal>();

                for (DateTime day = startOfMonth; day <= endOfMonth; day = day.AddDays(1))
                {
                    if (day.DayOfWeek == DayOfWeek.Saturday || day.DayOfWeek == DayOfWeek.Sunday || holidays.Contains(day))
                        continue;

                    var affiliationHours = personAffiliations
                        .Where(ap => ap.Start <= day && ap.End >= day)
                        .SelectMany(ap => affHours
                            .Where(ah => ah.AffId == ap.AffId && ah.StartDate <= day && ah.EndDate >= day))
                        .FirstOrDefault()?.Hours ?? 0;

                    var dedication = personDedications
                        .Where(d => d.Start <= day && d.End >= day)
                        .OrderByDescending(d => d.Type)
                        .FirstOrDefault();

                    decimal reduction = dedication?.Reduc ?? 0;
                    decimal adjustedHours = affiliationHours * (1 - reduction);

                    days[day] = Math.Round(adjustedHours, 1, MidpointRounding.AwayFromZero);
                }

                result[(personId, year, month)] = days;
            }
        }

        return result;
    }


    public decimal CalculateGlobalHoursFromCache(
    int personId,
    int year,
    int month,
    Dictionary<(int personId, int year, int month), Dictionary<DateTime, decimal>> cache,
    List<Leave> preloadedLeaves,
    List<NationalHoliday> preloadedHolidays)
    {
        if (!cache.TryGetValue((personId, year, month), out var daysWithDedication))
            return 0;

        var leaves = preloadedLeaves
            .Where(l => l.PersonId == personId && l.Day.Year == year && l.Day.Month == month)
            .ToList();

        var holidays = preloadedHolidays
            .Where(h => h.Date.Year == year && h.Date.Month == month)
            .Select(h => h.Date)
            .ToHashSet();

        decimal totalHours = 0;

        foreach (var entry in daysWithDedication)
        {
            var day = entry.Key;
            var baseHours = entry.Value;

            if (holidays.Contains(day))
                continue;

            var leave = leaves.FirstOrDefault(l => l.Day.Date == day.Date);

            if (leave != null)
            {
                if (leave.Type == 11 || leave.Type == 12)
                {
                    decimal adjusted = Math.Round(baseHours * (1 - leave.LeaveReduction), 2);
                    totalHours += adjusted;
                }
                else
                {
                    continue; // baja completa o vacaciones
                }
            }
            else
            {
                totalHours += baseHours;
            }
        }

        return Math.Round(totalHours, 2);
    }

    public async Task<decimal> CalculateTotalWorkHoursForPersonAsync(int personId, int year, int month)
    {
        var startDate = new DateTime(year, month, 1);
        var endDate = startDate.AddMonths(1).AddDays(-1);

        // 1. Obtener horas por día según dedicación (sin redondear)
        var hoursPerDay = await CalculateDailyWorkHoursWithDedicationNotRounded(personId, year, month);

        // 2. Obtener reducciones por baja parcial (tipo 11 o 12)
        var leaveReductions = await _context.Leaves
            .Where(l => l.PersonId == personId &&
                        l.Day >= startDate &&
                        l.Day <= endDate &&
                        (l.Type == 11 || l.Type == 12) &&
                        l.LeaveReduction > 0 && l.LeaveReduction <= 1)
            .ToDictionaryAsync(l => l.Day, l => l.LeaveReduction);

        // Aplicar reducciones por baja parcial
        foreach (var day in hoursPerDay.Keys.ToList())
        {
            if (leaveReductions.TryGetValue(day, out var reduction))
            {
                hoursPerDay[day] = Math.Round(hoursPerDay[day] * (1 - reduction), 2);
            }
        }

        // 3. Obtener días de baja completa y festivos
        var fullLeaves = await GetLeavesForPerson(personId, year, month);
        var holidays = await GetHolidaysForMonth(year, month);

        // 4. Filtrar días no válidos
        var validDays = hoursPerDay
            .Where(entry => !fullLeaves.Any(l => l.Day == entry.Key) && !holidays.Contains(entry.Key))
            .ToList();

        // 5. Sumar total
        var totalWorkHours = validDays.Sum(entry => entry.Value);

        return Math.Round(totalWorkHours, 2);
    }

    public async Task<Dictionary<(int PersonId, DateTime MonthStart), decimal>> GetDeclaredHoursPerYearByPersonAsync(int year)
    {
        var monthStart = new DateTime(year, 1, 1);
        var monthEnd = new DateTime(year, 12, 31);

        var result = await _context.Timesheets
            .Where(ts => ts.Day >= monthStart && ts.Day <= monthEnd)
            .Join(_context.Wpxpeople,
                ts => ts.WpxPersonId,
                wpx => wpx.Id,
                (ts, wpx) => new
                {
                    ts.Hours,
                    wpx.Person,
                    ts.Day
                })
            .GroupBy(x => new { x.Person, Month = new DateTime(x.Day.Year, x.Day.Month, 1) })
            .Select(g => new
            {
                g.Key.Person,
                g.Key.Month,
                TotalHours = g.Sum(x => x.Hours)
            })
            .ToDictionaryAsync(
                x => (x.Person, x.Month),
                x => Math.Round(x.TotalHours, 2)
            );

        return result;
    }


    /// <summary>
    /// Calcula el número total de horas teóricas que una persona debería trabajar en un mes completo,
    /// considerando únicamente los días laborables (excluyendo fines de semana y festivos).
    /// Si la persona tiene alguna afiliación activa durante el mes, se toma la jornada diaria asociada
    /// a esa afiliación y se aplica a todos los días laborables del mes, sin tener en cuenta si la afiliación
    /// cubre cada día individualmente. No se consideran bajas ni ausencias.
    /// </summary>
    /// <param name="personId">ID de la persona</param>
    /// <param name="year">Año del mes a evaluar</param>
    /// <param name="month">Mes a evaluar (1-12)</param>
    /// <returns>Total de horas teóricas del mes</returns>

    public async Task<decimal> CalculateTheoreticalMonthlyHoursAsync(int personId, int year, int month)
    {
        var startOfMonth = new DateTime(year, month, 1);
        var endOfMonth = startOfMonth.AddMonths(1).AddDays(-1);

        // Obtener afiliación principal (cualquiera que esté activa durante el mes)
        var affiliation = await _context.AffxPersons
            .Where(ap => ap.PersonId == personId && ap.Start <= endOfMonth && ap.End >= startOfMonth)
            .Select(ap => ap.AffId)
            .FirstOrDefaultAsync();

        if (affiliation == 0)
            return 0;

        // Obtener horas diarias de esa afiliación (válidas para ese mes)
        var dailyHours = await _context.AffHours
            .Where(ah => ah.AffId == affiliation && ah.StartDate <= endOfMonth && ah.EndDate >= startOfMonth)
            .Select(ah => ah.Hours)
            .FirstOrDefaultAsync();

        if (dailyHours == 0)
            return 0;

        // Obtener días laborables del mes
        var holidays = await _context.NationalHolidays
            .Where(h => h.Date >= startOfMonth && h.Date <= endOfMonth)
            .Select(h => h.Date)
            .ToListAsync();

        var workingDays = Enumerable.Range(0, (endOfMonth - startOfMonth).Days + 1)
            .Select(offset => startOfMonth.AddDays(offset))
            .Where(day => day.DayOfWeek != DayOfWeek.Saturday && day.DayOfWeek != DayOfWeek.Sunday && !holidays.Contains(day))
            .Count();

        return workingDays * dailyHours;
    }


    public async Task<Dictionary<DateTime, decimal>> GetEstimatedWorkedDaysPerMonthForPersonInProject(
    int personId, DateTime startDate, DateTime endDate, int projectId)
    {
        // Normalizar fin de rango al último día del mes
        endDate = new DateTime(endDate.Year, endDate.Month, DateTime.DaysInMonth(endDate.Year, endDate.Month));

        // 1) Obtener el esfuerzo mensual en el proyecto
        var monthlyEfforts = await CalculateMonthlyEffortForPersonInProject(personId, startDate, endDate, projectId);

        // 2) Obtener todas las afiliaciones y sus horas de referencia
        var affiliations = await _context.AffxPersons
            .Where(a => a.PersonId == personId &&
                        a.Start <= endDate && a.End >= startDate)
            .ToListAsync();

        var affHoursList = await _context.AffHours.ToListAsync();

        var result = new Dictionary<DateTime, decimal>();

        // 3) Iterar por cada mes dentro del rango
        for (var cursor = new DateTime(startDate.Year, startDate.Month, 1);
             cursor <= endDate;
             cursor = cursor.AddMonths(1))
        {
            // Effort del mes en este proyecto (0 si no hay)
            decimal effort = monthlyEfforts.TryGetValue(cursor, out var e) ? e : 0m;

            if (effort <= 0)
            {
                // Sin esfuerzo asignado → 0 días estimados
                result[cursor] = 0.0m;
                continue;
            }

            // 4) Calcular las horas totales del mes (según dedicación activa)
            var hoursPerDayWithDedication = await CalculateDailyWorkHoursWithDedicationNotRounded(personId, cursor.Year, cursor.Month);
            var totalMonthlyHours = hoursPerDayWithDedication.Values.Sum(); // Excluye fines de semana/festivos

            // 5) Obtener afiliaciones activas en este mes
            var monthAffiliations = affiliations
                .Where(a => a.Start <= cursor.AddMonths(1).AddDays(-1) && a.End >= cursor)
                .ToList();

            if (!monthAffiliations.Any())
            {
                // No hay afiliaciones activas → SIN AFILIACIÓN
                result[cursor] = -1;
                continue;
            }

            // 6) Obtener las horas base por día de la afiliación (mínimo de AffHours válidas ese mes)
            List<decimal> activeAffiliationHours = new List<decimal>();
            foreach (var affiliation in monthAffiliations)
            {
                var validAffHours = affHoursList
                    .Where(ah => ah.AffId == affiliation.AffId &&
                                 ah.StartDate <= cursor.AddMonths(1).AddDays(-1) &&
                                 ah.EndDate >= cursor)
                    .Select(ah => ah.Hours)
                    .Where(h => h > 0)
                    .ToList();

                if (validAffHours.Any())
                    activeAffiliationHours.AddRange(validAffHours);
            }

            if (!activeAffiliationHours.Any())
            {
                // No se encontraron horas base válidas
                result[cursor] = -1;
                continue;
            }

            var baseDailyHours = activeAffiliationHours.Min(); // Ej: 7.5 h/día

            // 7) Obtener reducción activa en Dedication para el mes
            var dedication = await _context.Dedications
                .Where(d => d.PersId == personId && d.Start <= cursor.AddMonths(1).AddDays(-1) && d.End >= cursor)
                .OrderByDescending(d => d.Type)
                .ThenByDescending(d => d.Start)
                .FirstOrDefaultAsync();

            var reduc = dedication?.Reduc ?? 0m; // Ej: 0.125 → 12.5%
            var factor = 1m - reduc;
            if (factor < 0m) factor = 0m;
            if (factor > 1m) factor = 1m;

            // 8) Calcular las horas/día efectivas (aplicando reducción)
            var effectiveDailyHours = Math.Round(baseDailyHours * factor, 1, MidpointRounding.AwayFromZero);

            // 9) Calcular horas estimadas del proyecto
            var estimatedProjectHours = Math.Round(totalMonthlyHours * effort, 1, MidpointRounding.AwayFromZero);

            // 10) Convertir a días estimados (redondeo a 1 decimal)
            decimal estimatedDays = estimatedProjectHours > 0
                ? Math.Round(estimatedProjectHours / effectiveDailyHours, 1, MidpointRounding.AwayFromZero)
                : 0.0m;

            // Guardar resultado
            result[cursor] = estimatedDays;

            // 11) Logging de diagnóstico (puedes dejarlo en DEBUG mientras pruebas)
            _logger.LogInformation(
              "EST-DEBUG | P{PersonId} | Proj{ProjectId} | {Year}-{Month:D2} | Effort={Effort:P1} | BaseDaily={BaseDaily:F2} | Reduc={Reduc:P1} | EffDaily={EffDaily:F2} | TotalMonth={Total:F1} | EstHours={EstH:F1} | EstDays={EstD:F1}",
              personId, projectId, cursor.Year, cursor.Month,
              effort, baseDailyHours, reduc, effectiveDailyHours, totalMonthlyHours, estimatedProjectHours, estimatedDays
            );
        }

        return result;
    }

    private async Task<(decimal? EffectiveDailyHours, decimal? BaseDailyHours, decimal ReducUsed)>
    GetEffectiveDailyHoursForMonthAsync(int personId, DateTime monthStart, DateTime monthEnd)
    {
        // 1) Afiliaciones activas
        var affIds = await _context.AffxPersons
            .Where(a => a.PersonId == personId && a.Start <= monthEnd && a.End >= monthStart)
            .Select(a => a.AffId)
            .Distinct()
            .ToListAsync();

        if (!affIds.Any())
            return (null, null, 0m); // SIN AFILIACIÓN

        // 2) Horas/día base desde AffHours (válidas ese mes) → usar la MÍNIMA
        var baseCandidates = await _context.AffHours
            .Where(ah => affIds.Contains(ah.AffId) &&
                         ah.StartDate <= monthEnd &&
                         ah.EndDate >= monthStart &&
                         ah.Hours > 0)
            .Select(ah => ah.Hours)
            .ToListAsync();

        if (!baseCandidates.Any())
            return (null, null, 0m); // SIN AFILIACIÓN efectiva

        var baseDailyHours = baseCandidates.Min();

        // 3) Reducción activa en Dedication (elige la línea más relevante)
        var dedication = await _context.Dedications
            .Where(d => d.PersId == personId && d.Start <= monthEnd && d.End >= monthStart)
            .OrderByDescending(d => d.Type)   // tu prioridad habitual
            .ThenByDescending(d => d.Start)
            .FirstOrDefaultAsync();

        var reduc = dedication?.Reduc ?? 0m;  // ej. 0.125
        var factor = 1m - reduc;
        if (factor < 0m) factor = 0m;
        if (factor > 1m) factor = 1m;

        var effective = Math.Round(baseDailyHours * factor, 1, MidpointRounding.AwayFromZero);
        return (effective, baseDailyHours, reduc);
    }

    public async Task<Dictionary<DateTime, decimal>> CalculateDailyWorkHoursWithDedicationAndLeaves(
    int personId, int year, int month)
    {
        var dailyWorkHours = new Dictionary<DateTime, decimal>();
        DateTime startDate = new DateTime(year, month, 1);
        DateTime endDate = startDate.AddMonths(1).AddDays(-1);
        int daysInMonth = DateTime.DaysInMonth(year, month);

        // Afiliaciones del mes
        var affiliations = await _context.AffxPersons
            .Where(ap => ap.PersonId == personId && ap.Start <= endDate && ap.End >= startDate)
            .ToListAsync();

        // Horas de afiliación relevantes
        var affIds = affiliations.Select(a => a.AffId).Distinct().ToList();
        var affHoursList = await _context.AffHours
            .Where(ah => affIds.Contains(ah.AffId) && ah.StartDate <= endDate && ah.EndDate >= startDate)
            .ToListAsync();

        // Dedicaciones
        var dedications = await _context.Dedications
            .Where(d => d.PersId == personId && d.Start <= endDate && d.End >= startDate)
            .ToListAsync();

        // Bajas / vacaciones del mes (LeaveReduction + Type)
        var leaves = await _context.Leaves
            .Where(l => l.PersonId == personId && l.Day >= startDate && l.Day <= endDate)
            .ToDictionaryAsync(l => l.Day, l => new { l.LeaveReduction, l.Type });

        for (int day = 1; day <= daysInMonth; day++)
        {
            DateTime currentDate = new DateTime(year, month, day);

            // Saltar findes y festivos
            if (currentDate.DayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday || await IsHoliday(currentDate))
                continue;

            // Horas base por afiliación en ese día
            var baseHours = affiliations
                .Where(ap => currentDate >= ap.Start && currentDate <= ap.End)
                .SelectMany(ap => affHoursList.Where(ah => ah.AffId == ap.AffId && currentDate >= ah.StartDate && currentDate <= ah.EndDate))
                .Select(ah => ah.Hours)
                .FirstOrDefault();

            // Dedicación aplicable (Type más alto)
            var dedication = dedications
                .Where(d => currentDate >= d.Start && currentDate <= d.End)
                .OrderByDescending(d => d.Type)
                .Select(d => d.Reduc)
                .FirstOrDefault();

            // Baja/ausencia del día (si existe)
            leaves.TryGetValue(currentDate, out var leave);
            var leaveReduction = leave?.LeaveReduction ?? 0m;
            var leaveType = leave?.Type ?? 0;

            decimal dailyHours;
            if (leaveType == 12) // paternidad: misma regla especial que usas en otros cálculos
            {
                dailyHours = baseHours * (1 - dedication) * (1 - leaveReduction);
            }
            else
            {
                var totalReduction = Math.Min(1m, dedication + leaveReduction);
                dailyHours = baseHours * (1 - totalReduction);
            }

            // Redondeo igual que el método original
            dailyHours = RoundToNearestHalfOrWhole(dailyHours);

            dailyWorkHours[currentDate] = dailyHours;
        }

        return dailyWorkHours;
    }


}



